# Documentación Técnica: proto/generated/services/tokens/v1/tokensv1connect/service.connect.go

## Descripción General

Este archivo es **código generado automáticamente** por `protoc-gen-connect-go` a partir del archivo `services/tokens/v1/service.proto`. Implementa las interfaces y clientes ConnectRPC para el servicio de gestión de tokens de dispositivos móviles. A diferencia del servicio de chat que tiene múltiples métodos, este servicio se enfoca específicamente en el registro y gestión de tokens para notificaciones push.

## Estructura del Archivo

### Información de Generación

```go
// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: services/tokens/v1/service.proto
```

**Análisis:**
- **Generación automática**: No debe editarse manualmente
- **Fuente**: Generado desde `services/tokens/v1/service.proto`
- **Herramienta**: `protoc-gen-connect-go` del ecosistema ConnectRPC

### Importaciones

```go
import (
    connect "connectrpc.com/connect"
    context "context"
    errors "errors"
    v1 "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/proto/generated/services/tokens/v1"
    http "net/http"
    strings "strings"
)
```

**Análisis de Dependencias:**
- **`connect`**: Framework ConnectRPC para servicios gRPC-Web
- **`context`**: Manejo de contexto y cancelación
- **`errors`**: Creación de errores estándar
- **`v1`**: Tipos de datos generados desde Protocol Buffers
- **`http`**: Servidor HTTP estándar
- **`strings`**: Manipulación de strings para URLs

### Verificación de Compatibilidad

```go
const _ = connect.IsAtLeastVersion1_13_0
```

**Propósito:**
- **Verificación en tiempo de compilación**: Asegura compatibilidad de versiones
- **Prevención de errores**: Evita incompatibilidades entre versiones
- **Versión mínima**: Requiere ConnectRPC v1.13.0 o superior

## Constantes de Servicio

### Nombre del Servicio

```go
const (
    // TokensServiceName is the fully-qualified name of the TokensService service.
    TokensServiceName = "services.tokens.v1.TokensService"
)
```

**Análisis:**
- **Nombre completo**: Identificador único del servicio
- **Formato**: `package.service` siguiendo convenciones de Protocol Buffers
- **Uso**: Registro de servicios, métricas, logging

### Procedimiento RPC

```go
const (
    // TokensServiceSaveTokenProcedure is the fully-qualified name of the TokensService's SaveToken RPC.
    TokensServiceSaveTokenProcedure = "/services.tokens.v1.TokensService/SaveToken"
)
```

**Análisis del Procedimiento:**

#### Formato del Procedimiento
- **Patrón**: `/package.service/Method`
- **Uso**: Ruta HTTP para gRPC-Web y Connect
- **Identificación**: Nombre único para la operación

#### Funcionalidad del Método
- **Propósito**: Registrar tokens de dispositivos para notificaciones push
- **Plataformas**: iOS (APNS), Android (FCM), Web (Web Push)
- **Autenticación**: Requiere token privado (🔒)

## Interface TokensServiceClient

```go
type TokensServiceClient interface {
    // 🔒 Need private token to access this endpoint
    // - platform: IOS, ANDROID, WEB
    SaveToken(context.Context, *connect.Request[v1.SaveTokenRequest]) (*connect.Response[v1.SaveTokenResponse], error)
}
```

**Análisis de la Interface:**

### Características del Método SaveToken
- **Autenticación**: Requiere token privado (🔒)
- **Plataformas soportadas**: IOS, ANDROID, WEB
- **Context-aware**: Recibe `context.Context` para cancelación
- **Type Safety**: Uso de generics para requests y responses tipados
- **Error Handling**: Retorno explícito de errores

### Funcionalidad Específica
- **Registro de tokens**: Almacena tokens FCM/APNS/Web Push
- **Actualización**: Permite actualizar tokens existentes
- **Múltiples dispositivos**: Un usuario puede tener múltiples tokens
- **Metadatos**: Incluye información del dispositivo y plataforma

## Función NewTokensServiceClient

```go
func NewTokensServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) TokensServiceClient {
    baseURL = strings.TrimRight(baseURL, "/")
    tokensServiceMethods := v1.File_services_tokens_v1_service_proto.Services().ByName("TokensService").Methods()
    return &tokensServiceClient{
        saveToken: connect.NewClient[v1.SaveTokenRequest, v1.SaveTokenResponse](
            httpClient,
            baseURL+TokensServiceSaveTokenProcedure,
            connect.WithSchema(tokensServiceMethods.ByName("SaveToken")),
            connect.WithClientOptions(opts...),
        ),
    }
}
```

**Análisis de la Función:**

### Parámetros
- **`httpClient`**: Cliente HTTP para realizar requests
- **`baseURL`**: URL base del servidor (ej: `https://api.example.com`)
- **`opts`**: Opciones adicionales de configuración

### Proceso de Construcción

#### 1. Normalización de URL
```go
baseURL = strings.TrimRight(baseURL, "/")
```
- **Propósito**: Elimina slash final para evitar URLs malformadas
- **Resultado**: URLs consistentes

#### 2. Obtención de Metadata
```go
tokensServiceMethods := v1.File_services_tokens_v1_service_proto.Services().ByName("TokensService").Methods()
```
- **Propósito**: Obtiene metadata de métodos desde Protocol Buffers
- **Uso**: Configuración de schema para validación

#### 3. Creación del Cliente
```go
saveToken: connect.NewClient[v1.SaveTokenRequest, v1.SaveTokenResponse](
    httpClient,
    baseURL+TokensServiceSaveTokenProcedure,
    connect.WithSchema(tokensServiceMethods.ByName("SaveToken")),
    connect.WithClientOptions(opts...),
)
```

**Características:**
- **Type Safety**: Generics para request/response tipados
- **URL Completa**: Combina baseURL con procedure
- **Schema**: Metadata para validación
- **Opciones**: Configuración personalizable

## Estructura tokensServiceClient

```go
type tokensServiceClient struct {
    saveToken *connect.Client[v1.SaveTokenRequest, v1.SaveTokenResponse]
}
```

**Análisis:**
- **Simplicidad**: Solo un cliente para el único método
- **Type Safety**: Cliente tipado específicamente
- **Reutilización**: Cliente reutilizable para múltiples calls

### Implementación del Método

```go
func (c *tokensServiceClient) SaveToken(ctx context.Context, req *connect.Request[v1.SaveTokenRequest]) (*connect.Response[v1.SaveTokenResponse], error) {
    return c.saveToken.CallUnary(ctx, req)
}
```

**Patrón:**
- **Delegación**: Delega al cliente específico
- **CallUnary**: Para método request-response
- **Simplicidad**: Implementación directa sin lógica adicional

## Interface TokensServiceHandler

```go
type TokensServiceHandler interface {
    // 🔒 Need private token to access this endpoint
    // - platform: IOS, ANDROID, WEB
    SaveToken(context.Context, *connect.Request[v1.SaveTokenRequest]) (*connect.Response[v1.SaveTokenResponse], error)
}
```

**Análisis:**
- **Misma signature**: Idéntica al cliente para consistencia
- **Implementación del servidor**: Define lo que debe implementar el servidor
- **Documentación**: Incluye mismos comentarios sobre autenticación y plataformas

## Función NewTokensServiceHandler

```go
func NewTokensServiceHandler(svc TokensServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
    tokensServiceMethods := v1.File_services_tokens_v1_service_proto.Services().ByName("TokensService").Methods()
    tokensServiceSaveTokenHandler := connect.NewUnaryHandler(
        TokensServiceSaveTokenProcedure,
        svc.SaveToken,
        connect.WithSchema(tokensServiceMethods.ByName("SaveToken")),
        connect.WithHandlerOptions(opts...),
    )
    return "/services.tokens.v1.TokensService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.URL.Path {
        case TokensServiceSaveTokenProcedure:
            tokensServiceSaveTokenHandler.ServeHTTP(w, r)
        default:
            http.NotFound(w, r)
        }
    })
}
```

**Análisis del Proceso:**

### 1. Creación del Handler
```go
tokensServiceSaveTokenHandler := connect.NewUnaryHandler(
    TokensServiceSaveTokenProcedure,
    svc.SaveToken,
    connect.WithSchema(tokensServiceMethods.ByName("SaveToken")),
    connect.WithHandlerOptions(opts...),
)
```
- **Unary Handler**: Para método request-response
- **Procedure**: Ruta específica del método
- **Implementation**: Función del servicio a ejecutar
- **Schema**: Metadata para validación

### 2. Router HTTP
```go
return "/services.tokens.v1.TokensService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    case TokensServiceSaveTokenProcedure:
        tokensServiceSaveTokenHandler.ServeHTTP(w, r)
    default:
        http.NotFound(w, r)
    }
})
```
- **Mount Path**: `"/services.tokens.v1.TokensService/"` para registro
- **Path Matching**: Switch simple con un solo caso
- **404**: Paths no reconocidos retornan Not Found

### 3. Simplicidad vs Chat Service
- **Un solo método**: Mucho más simple que el servicio de chat
- **Switch mínimo**: Solo un case vs múltiples en chat
- **Mantenimiento**: Más fácil de mantener y entender

## Estructura UnimplementedTokensServiceHandler

```go
type UnimplementedTokensServiceHandler struct{}

func (UnimplementedTokensServiceHandler) SaveToken(context.Context, *connect.Request[v1.SaveTokenRequest]) (*connect.Response[v1.SaveTokenResponse], error) {
    return nil, connect.NewError(connect.CodeUnimplemented, errors.New("services.tokens.v1.TokensService.SaveToken is not implemented"))
}
```

**Propósito:**
- **Base Implementation**: Implementación base que retorna "no implementado"
- **Desarrollo Incremental**: Permite implementar métodos gradualmente
- **Testing**: Útil para testing de métodos específicos
- **Error Estándar**: Retorna error gRPC estándar `UNIMPLEMENTED`

## Protocolos Soportados

### 1. gRPC Nativo
- **Transport**: HTTP/2
- **Encoding**: Protocol Buffers binario
- **Uso**: Comunicación servidor-servidor

### 2. gRPC-Web
- **Transport**: HTTP/1.1 o HTTP/2
- **Encoding**: Protocol Buffers binario
- **Uso**: Navegadores web con proxy

### 3. Connect Protocol
- **Transport**: HTTP/1.1 o HTTP/2
- **Encoding**: JSON o Protocol Buffers
- **Uso**: APIs REST-like con type safety

## Mapeo HTTP

### Ruta del Servicio

Basándose en el descriptor, el método SaveToken se mapea a:

```
POST /api/tokens/v1/save
```

**Características:**
- **HTTP Method**: POST (para operaciones de escritura)
- **Path**: `/api/tokens/v1/save`
- **Body**: Request completo en JSON o Protocol Buffers
- **Headers**: Autenticación requerida

## Casos de Uso

### 1. Registro de Token FCM (Android)

```go
client := tokensv1connect.NewTokensServiceClient(
    http.DefaultClient,
    "https://api.example.com",
)

request := &tokensv1.SaveTokenRequest{
    Token:           "fcm_token_abc123...",
    Platform:        "ANDROID",
    PlatformVersion: "14",
    Device:          "Samsung Galaxy S24",
    Lang:            "es",
    IsVoip:          false,
    Debug:           false,
}

response, err := client.SaveToken(ctx, connect.NewRequest(request))
if err != nil {
    log.Printf("Error: %v", err)
    return
}

if response.Msg.GetSuccess() {
    log.Println("Token registrado exitosamente")
}
```

### 2. Registro de Token APNS (iOS)

```go
request := &tokensv1.SaveTokenRequest{
    Token:           "apns_token_def456...",
    Platform:        "IOS",
    PlatformVersion: "17.2",
    Device:          "iPhone 15 Pro",
    TokenVoip:       "voip_token_789...",
    IsVoip:          true,
    Lang:            "en",
    Debug:           false,
}

response, err := client.SaveToken(ctx, connect.NewRequest(request))
```

### 3. Registro de Token Web Push

```go
request := &tokensv1.SaveTokenRequest{
    Token:           "web_push_token_ghi789...",
    Platform:        "WEB",
    PlatformVersion: "Chrome 120",
    Device:          "Desktop Chrome",
    Lang:            "fr",
    IsVoip:          false,
    Debug:           false,
}

response, err := client.SaveToken(ctx, connect.NewRequest(request))
```

## Configuración de Cliente

### Opciones Comunes

```go
client := tokensv1connect.NewTokensServiceClient(
    http.DefaultClient,
    "https://api.example.com",
    connect.WithGRPC(),                    // Usar protocolo gRPC
    connect.WithCompression("gzip"),       // Compresión
    connect.WithClientOptions(
        connect.WithInterceptors(authInterceptor), // Middleware
    ),
)
```

### Interceptor de Autenticación

```go
func authInterceptor() connect.UnaryInterceptorFunc {
    return func(next connect.UnaryFunc) connect.UnaryFunc {
        return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {
            req.Header().Set("Authorization", "Bearer "+token)
            return next(ctx, req)
        }
    }
}
```

## Testing

### Unit Tests

```go
func TestSaveToken(t *testing.T) {
    // Mock handler
    handler := &MockTokensServiceHandler{}
    handler.On("SaveToken", mock.Anything, mock.Anything).
        Return(&connect.Response[tokensv1.SaveTokenResponse]{
            Msg: &tokensv1.SaveTokenResponse{Success: true},
        }, nil)
    
    // Create test server
    _, httpHandler := tokensv1connect.NewTokensServiceHandler(handler)
    server := httptest.NewServer(httpHandler)
    defer server.Close()
    
    // Create client
    client := tokensv1connect.NewTokensServiceClient(
        http.DefaultClient,
        server.URL,
    )
    
    // Test request
    request := &tokensv1.SaveTokenRequest{
        Token:    "test_token",
        Platform: "ANDROID",
        Device:   "Test Device",
    }
    
    response, err := client.SaveToken(context.Background(), connect.NewRequest(request))
    
    assert.NoError(t, err)
    assert.True(t, response.Msg.GetSuccess())
    handler.AssertExpectations(t)
}
```

### Integration Tests

```go
func TestTokensServiceIntegration(t *testing.T) {
    // Setup real service
    service := &realTokensServiceHandler{
        repo: setupTestRepository(t),
    }
    
    _, httpHandler := tokensv1connect.NewTokensServiceHandler(service)
    server := httptest.NewServer(httpHandler)
    defer server.Close()
    
    client := tokensv1connect.NewTokensServiceClient(
        http.DefaultClient,
        server.URL,
    )
    
    // Test token registration
    request := &tokensv1.SaveTokenRequest{
        Token:           generateValidFCMToken(),
        Platform:        "ANDROID",
        PlatformVersion: "14",
        Device:          "Pixel 8",
        Lang:            "es",
    }
    
    response, err := client.SaveToken(context.Background(), connect.NewRequest(request))
    
    assert.NoError(t, err)
    assert.True(t, response.Msg.GetSuccess())
    
    // Verify token was saved
    // ... verification logic
}
```

## Comparación con Chat Service

### Similitudes
- **Misma estructura**: Patrón idéntico de generación
- **Mismas interfaces**: Client, Handler, Unimplemented
- **Mismos protocolos**: gRPC, gRPC-Web, Connect
- **Misma configuración**: Opciones y middleware

### Diferencias
- **Simplicidad**: Un solo método vs 23 métodos
- **Funcionalidad**: Específico vs general
- **Complejidad**: Router simple vs complejo
- **Mantenimiento**: Más fácil de mantener

## Mejores Prácticas

1. **Reutilización de cliente**: Crear una vez, usar múltiples veces
2. **Manejo de errores**: Verificar errores específicos de ConnectRPC
3. **Context con timeout**: Siempre usar context con timeout apropiado
4. **Autenticación**: Implementar interceptor de autenticación
5. **Logging**: Agregar logging para debugging
6. **Rate limiting**: Implementar rate limiting para prevenir abuso

## Consideraciones de Seguridad

### Validación de Tokens
- **Formato**: Validar formato de tokens FCM/APNS
- **Longitud**: Verificar longitud apropiada
- **Caracteres**: Solo caracteres válidos

### Rate Limiting
- **Por usuario**: Limitar registros por usuario
- **Por IP**: Limitar requests por IP
- **Por tiempo**: Ventanas de tiempo para prevenir spam

### Autenticación
- **Token requerido**: Siempre verificar autenticación
- **Permisos**: Verificar permisos del usuario
- **Expiración**: Manejar tokens expirados

Este archivo proporciona una interfaz simple pero completa para la gestión de tokens de dispositivos, siguiendo los mismos patrones robustos del servicio de chat pero con una funcionalidad más específica y enfocada.