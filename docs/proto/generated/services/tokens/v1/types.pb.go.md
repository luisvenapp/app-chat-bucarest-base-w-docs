# Documentación Técnica: proto/generated/services/tokens/v1/types.pb.go

## Descripción General

Este archivo es **código generado automáticamente** por `protoc-gen-go` a partir del archivo `services/tokens/v1/types.proto`. Contiene las estructuras de datos utilizadas por el servicio de tokens para la gestión de tokens de dispositivos móviles y notificaciones push. A diferencia del servicio de chat que tiene múltiples tipos complejos, este servicio se enfoca en tipos simples pero específicos para el registro de tokens de dispositivos.

## Estructura del Archivo

### Información de Generación

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//  protoc-gen-go v1.36.8
//  protoc        (unknown)
// source: services/tokens/v1/types.proto
```

**Análisis:**
- **Herramienta**: `protoc-gen-go` versión 1.36.8
- **Fuente**: `services/tokens/v1/types.proto`
- **Prohibición de edición**: Código generado automáticamente

### Importaciones

```go
import (
    protoreflect "google.golang.org/protobuf/reflect/protoreflect"
    protoimpl "google.golang.org/protobuf/runtime/protoimpl"
    reflect "reflect"
    sync "sync"
    unsafe "unsafe"
)
```

**Análisis de Dependencias:**

#### `protobuf/reflect/protoreflect`
- **Propósito**: Reflection API para Protocol Buffers
- **Uso**: Introspección de tipos en runtime
- **Características**: Acceso dinámico a metadata

#### `protobuf/runtime/protoimpl`
- **Propósito**: Runtime de implementación de Protocol Buffers
- **Uso**: Funciones internas para generación de código
- **Optimización**: Implementación optimizada para Go

#### Librerías Estándar
- **`reflect`**: Reflection de Go para introspección
- **`sync`**: Primitivas de sincronización
- **`unsafe`**: Operaciones unsafe para performance

### Verificación de Versiones

```go
const (
    // Verify that this generated code is sufficiently up-to-date.
    _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    // Verify that runtime/protoimpl is sufficiently up-to-date.
    _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)
```

**Propósito:**
- **Compatibilidad**: Verifica compatibilidad entre código generado y runtime
- **Prevención**: Evita errores por versiones incompatibles
- **Compilación**: Verificación en tiempo de compilación

## Estructuras de Datos

### SaveTokenRequest

```go
type SaveTokenRequest struct {
    state           protoimpl.MessageState `protogen:"open.v1"`
    Token           string                 `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
    Platform        string                 `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"` //platform: IOS, ANDROID, WEB
    PlatformVersion string                 `protobuf:"bytes,3,opt,name=platform_version,json=platformVersion,proto3" json:"platform_version,omitempty"`
    Device          string                 `protobuf:"bytes,4,opt,name=device,proto3" json:"device,omitempty"`
    TokenVoip       string                 `protobuf:"bytes,5,opt,name=token_voip,json=tokenVoip,proto3" json:"token_voip,omitempty"`
    IsVoip          bool                   `protobuf:"varint,6,opt,name=is_voip,json=isVoip,proto3" json:"is_voip,omitempty"`
    Debug           bool                   `protobuf:"varint,7,opt,name=debug,proto3" json:"debug,omitempty"`
    Lang            string                 `protobuf:"bytes,8,opt,name=lang,proto3" json:"lang,omitempty"`
    unknownFields   protoimpl.UnknownFields
    sizeCache       protoimpl.SizeCache
}
```

**Análisis Detallado de Campos:**

#### Campos Principales

##### `Token string`
- **Propósito**: Token principal del dispositivo para notificaciones push
- **Tipos**: FCM token (Android), APNS token (iOS), Web Push token (Web)
- **Formato**: String largo y único generado por el servicio de notificaciones
- **Ejemplo**: `"fcm_token_abc123def456..."` o `"apns_token_xyz789..."`

##### `Platform string`
- **Propósito**: Identificar la plataforma del dispositivo
- **Valores válidos**: "IOS", "ANDROID", "WEB"
- **Uso**: Determinar qué servicio de notificaciones usar
- **Validación**: Debe ser uno de los valores específicos

##### `PlatformVersion string`
- **Propósito**: Versión del sistema operativo o navegador
- **Ejemplos**: 
  - iOS: "17.2", "16.5"
  - Android: "14", "13", "API 34"
  - Web: "Chrome 120", "Firefox 118"
- **Uso**: Compatibilidad de características de notificaciones

##### `Device string`
- **Propósito**: Modelo o identificación del dispositivo
- **Ejemplos**:
  - iOS: "iPhone 15 Pro", "iPad Air"
  - Android: "Samsung Galaxy S24", "Pixel 8"
  - Web: "Desktop Chrome", "Mobile Safari"
- **Uso**: Analytics y debugging

#### Campos Específicos de VoIP

##### `TokenVoip string`
- **Propósito**: Token específico para notificaciones VoIP (principalmente iOS)
- **Uso**: Notificaciones de llamadas que pueden despertar la app
- **Plataforma**: Principalmente iOS APNS VoIP
- **Opcional**: Solo requerido si `IsVoip` es true

##### `IsVoip bool`
- **Propósito**: Indica si el token soporta notificaciones VoIP
- **Uso**: Determinar si se pueden enviar notificaciones de llamadas
- **Comportamiento**: Si es true, `TokenVoip` debería estar presente

#### Campos de Configuración

##### `Debug bool`
- **Propósito**: Indica si es un token de desarrollo/debug
- **Uso**: Separar tokens de producción de desarrollo
- **Comportamiento**: Tokens debug pueden usar sandbox de APNS

##### `Lang string`
- **Propósito**: Idioma preferido del usuario
- **Formato**: Código ISO 639-1 ("es", "en", "fr")
- **Uso**: Localización de notificaciones

### SaveTokenResponse

```go
type SaveTokenResponse struct {
    state         protoimpl.MessageState `protogen:"open.v1"`
    Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
    unknownFields protoimpl.UnknownFields
    sizeCache     protoimpl.SizeCache
}
```

**Análisis de la Respuesta:**

#### `Success bool`
- **Propósito**: Indica si el token fue registrado exitosamente
- **Valores**:
  - `true`: Token registrado/actualizado correctamente
  - `false`: Error en el registro (ver logs para detalles)
- **Simplicidad**: Respuesta minimalista enfocada en el resultado

## Funciones Getter Generadas

### Patrón de Getters para SaveTokenRequest

```go
func (x *SaveTokenRequest) GetToken() string {
    if x != nil {
        return x.Token
    }
    return ""
}

func (x *SaveTokenRequest) GetPlatform() string {
    if x != nil {
        return x.Platform
    }
    return ""
}

func (x *SaveTokenRequest) GetPlatformVersion() string {
    if x != nil {
        return x.PlatformVersion
    }
    return ""
}

func (x *SaveTokenRequest) GetDevice() string {
    if x != nil {
        return x.Device
    }
    return ""
}

func (x *SaveTokenRequest) GetTokenVoip() string {
    if x != nil {
        return x.TokenVoip
    }
    return ""
}

func (x *SaveTokenRequest) GetIsVoip() bool {
    if x != nil {
        return x.IsVoip
    }
    return false
}

func (x *SaveTokenRequest) GetDebug() bool {
    if x != nil {
        return x.Debug
    }
    return false
}

func (x *SaveTokenRequest) GetLang() string {
    if x != nil {
        return x.Lang
    }
    return ""
}
```

**Características:**
- **Null Safety**: Verificación automática de nil
- **Valores por defecto**: Retorna valores zero apropiados
- **Consistencia**: Mismo patrón para todos los campos

### Getter para SaveTokenResponse

```go
func (x *SaveTokenResponse) GetSuccess() bool {
    if x != nil {
        return x.Success
    }
    return false
}
```

**Simplicidad**: Solo un getter para el único campo

## Métodos de Protocol Buffers

### Métodos Estándar para SaveTokenRequest

```go
func (x *SaveTokenRequest) Reset() {
    *x = SaveTokenRequest{}
    mi := &file_services_tokens_v1_types_proto_msgTypes[0]
    ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    ms.StoreMessageInfo(mi)
}

func (x *SaveTokenRequest) String() string {
    return protoimpl.X.MessageStringOf(x)
}

func (*SaveTokenRequest) ProtoMessage() {}

func (x *SaveTokenRequest) ProtoReflect() protoreflect.Message {
    mi := &file_services_tokens_v1_types_proto_msgTypes[0]
    if x != nil {
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        if ms.LoadMessageInfo() == nil {
            ms.StoreMessageInfo(mi)
        }
        return ms
    }
    return mi.MessageOf(x)
}
```

### Métodos Estándar para SaveTokenResponse

```go
func (x *SaveTokenResponse) Reset() {
    *x = SaveTokenResponse{}
    mi := &file_services_tokens_v1_types_proto_msgTypes[1]
    ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    ms.StoreMessageInfo(mi)
}

func (x *SaveTokenResponse) String() string {
    return protoimpl.X.MessageStringOf(x)
}

func (*SaveTokenResponse) ProtoMessage() {}

func (x *SaveTokenResponse) ProtoReflect() protoreflect.Message {
    mi := &file_services_tokens_v1_types_proto_msgTypes[1]
    if x != nil {
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        if ms.LoadMessageInfo() == nil {
            ms.StoreMessageInfo(mi)
        }
        return ms
    }
    return mi.MessageOf(x)
}
```

**Funcionalidades:**
- **Reset**: Reinicia la estructura a valores por defecto
- **String**: Representación string para debugging
- **ProtoMessage**: Marca como mensaje de Protocol Buffers
- **ProtoReflect**: Soporte para reflection

## Descriptor de Archivo

### Variables Globales

```go
var File_services_tokens_v1_types_proto protoreflect.FileDescriptor

const file_services_tokens_v1_types_proto_rawDesc = "" +
    "\n" +
    "\x1eservices/tokens/v1/types.proto\x12\x12services.tokens.v1\"\xe9\x01\n" +
    "\x10SaveTokenRequest\x12\x14\n" +
    "\x05token\x18\x01 \x01(\tR\x05token\x12\x1a\n" +
    "\bplatform\x18\x02 \x01(\tR\bplatform\x12)\n" +
    // ... (continúa con descriptor binario)
```

### Arrays de Tipos

```go
var file_services_tokens_v1_types_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_services_tokens_v1_types_proto_goTypes = []any{
    (*SaveTokenRequest)(nil),  // 0: services.tokens.v1.SaveTokenRequest
    (*SaveTokenResponse)(nil), // 1: services.tokens.v1.SaveTokenResponse
}
var file_services_tokens_v1_types_proto_depIdxs = []int32{
    0, // [0:0] is the sub-list for method output_type
    0, // [0:0] is the sub-list for method input_type
    0, // [0:0] is the sub-list for extension type_name
    0, // [0:0] is the sub-list for extension extendee
    0, // [0:0] is the sub-list for field type_name
}
```

**Análisis:**
- **Simplicidad**: Solo 2 tipos de mensaje
- **Sin dependencias**: No hay dependencias entre tipos
- **Índices vacíos**: Arrays de dependencias están vacíos

## Función de Inicialización

### file_services_tokens_v1_types_proto_init

```go
func file_services_tokens_v1_types_proto_init() {
    if File_services_tokens_v1_types_proto != nil {
        return
    }
    type x struct{}
    out := protoimpl.TypeBuilder{
        File: protoimpl.DescBuilder{
            GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
            RawDescriptor: unsafe.Slice(unsafe.StringData(file_services_tokens_v1_types_proto_rawDesc), len(file_services_tokens_v1_types_proto_rawDesc)),
            NumEnums:      0,
            NumMessages:   2,
            NumExtensions: 0,
            NumServices:   0,
        },
        GoTypes:           file_services_tokens_v1_types_proto_goTypes,
        DependencyIndexes: file_services_tokens_v1_types_proto_depIdxs,
        MessageInfos:      file_services_tokens_v1_types_proto_msgTypes,
    }.Build()
    File_services_tokens_v1_types_proto = out.File
    file_services_tokens_v1_types_proto_goTypes = nil
    file_services_tokens_v1_types_proto_depIdxs = nil
}
```

**Características:**
- **NumMessages: 2**: Solo dos tipos de mensaje
- **NumEnums: 0**: Sin enumeraciones
- **NumServices: 0**: Sin servicios (están en service.proto)
- **Simplicidad**: Inicialización más simple que chat types

## Casos de Uso Típicos

### 1. Registro de Token Android (FCM)

```go
request := &tokensv1.SaveTokenRequest{
    Token:           "fcm_token_abc123def456ghi789...",
    Platform:        "ANDROID",
    PlatformVersion: "14",
    Device:          "Samsung Galaxy S24",
    TokenVoip:       "", // No aplica para Android
    IsVoip:          false,
    Debug:           false,
    Lang:            "es",
}

// Validación
if request.GetToken() == "" {
    return errors.New("token is required")
}
if request.GetPlatform() != "ANDROID" {
    return errors.New("invalid platform for FCM token")
}
```

### 2. Registro de Token iOS (APNS)

```go
request := &tokensv1.SaveTokenRequest{
    Token:           "apns_token_def456ghi789jkl012...",
    Platform:        "IOS",
    PlatformVersion: "17.2",
    Device:          "iPhone 15 Pro",
    TokenVoip:       "voip_token_mno345pqr678stu901...",
    IsVoip:          true,
    Debug:           false,
    Lang:            "en",
}

// Validación específica de iOS
if request.GetIsVoip() && request.GetTokenVoip() == "" {
    return errors.New("voip token required when is_voip is true")
}
```

### 3. Registro de Token Web Push

```go
request := &tokensv1.SaveTokenRequest{
    Token:           "web_push_token_vwx234yza567bcd890...",
    Platform:        "WEB",
    PlatformVersion: "Chrome 120",
    Device:          "Desktop Chrome",
    TokenVoip:       "", // No aplica para Web
    IsVoip:          false,
    Debug:           false,
    Lang:            "fr",
}

// Validación específica de Web
if request.GetPlatform() == "WEB" && request.GetIsVoip() {
    return errors.New("voip not supported for web platform")
}
```

### 4. Manejo de Respuesta

```go
response, err := client.SaveToken(ctx, connect.NewRequest(request))
if err != nil {
    log.Printf("Error saving token: %v", err)
    return err
}

if !response.Msg.GetSuccess() {
    log.Println("Token registration failed")
    return errors.New("token registration failed")
}

log.Println("Token registered successfully")
```

## Validación de Datos

### Validación de Platform

```go
func validatePlatform(platform string) error {
    validPlatforms := []string{"IOS", "ANDROID", "WEB"}
    for _, valid := range validPlatforms {
        if platform == valid {
            return nil
        }
    }
    return fmt.Errorf("invalid platform: %s, must be one of %v", platform, validPlatforms)
}
```

### Validación de Token

```go
func validateToken(token, platform string) error {
    if token == "" {
        return errors.New("token cannot be empty")
    }
    
    switch platform {
    case "ANDROID":
        // FCM tokens suelen tener un formato específico
        if len(token) < 100 {
            return errors.New("FCM token too short")
        }
    case "IOS":
        // APNS tokens tienen formato hexadecimal
        if len(token) != 64 && len(token) != 100 {
            return errors.New("invalid APNS token length")
        }
    case "WEB":
        // Web Push tokens varían según el navegador
        if len(token) < 50 {
            return errors.New("Web Push token too short")
        }
    }
    
    return nil
}
```

### Validación Completa

```go
func validateSaveTokenRequest(req *tokensv1.SaveTokenRequest) error {
    if err := validatePlatform(req.GetPlatform()); err != nil {
        return err
    }
    
    if err := validateToken(req.GetToken(), req.GetPlatform()); err != nil {
        return err
    }
    
    // Validación específica de VoIP
    if req.GetIsVoip() {
        if req.GetPlatform() != "IOS" {
            return errors.New("VoIP only supported on iOS")
        }
        if req.GetTokenVoip() == "" {
            return errors.New("VoIP token required when is_voip is true")
        }
    }
    
    // Validación de idioma
    if req.GetLang() != "" {
        if len(req.GetLang()) != 2 {
            return errors.New("language code must be 2 characters")
        }
    }
    
    return nil
}
```

## Serialización y Deserialización

### JSON Serialization

```go
// Convertir a JSON
request := &tokensv1.SaveTokenRequest{
    Token:    "test_token",
    Platform: "ANDROID",
    Device:   "Test Device",
}

jsonData, err := protojson.Marshal(request)
if err != nil {
    log.Printf("Error marshaling to JSON: %v", err)
    return
}

fmt.Printf("JSON: %s\n", string(jsonData))
// Output: {"token":"test_token","platform":"ANDROID","device":"Test Device"}
```

### JSON Deserialization

```go
// Convertir desde JSON
jsonStr := `{"token":"test_token","platform":"IOS","device":"iPhone","is_voip":true}`

var request tokensv1.SaveTokenRequest
err := protojson.Unmarshal([]byte(jsonStr), &request)
if err != nil {
    log.Printf("Error unmarshaling from JSON: %v", err)
    return
}

fmt.Printf("Token: %s, Platform: %s, VoIP: %t\n", 
    request.GetToken(), request.GetPlatform(), request.GetIsVoip())
```

### Binary Serialization

```go
// Protocol Buffers binario (más eficiente)
request := &tokensv1.SaveTokenRequest{
    Token:    "test_token",
    Platform: "ANDROID",
}

binaryData, err := proto.Marshal(request)
if err != nil {
    log.Printf("Error marshaling to binary: %v", err)
    return
}

// Deserializar
var decoded tokensv1.SaveTokenRequest
err = proto.Unmarshal(binaryData, &decoded)
if err != nil {
    log.Printf("Error unmarshaling from binary: %v", err)
    return
}
```

## Testing

### Unit Tests

```go
func TestSaveTokenRequest(t *testing.T) {
    tests := []struct {
        name    string
        request *tokensv1.SaveTokenRequest
        valid   bool
    }{
        {
            name: "valid android token",
            request: &tokensv1.SaveTokenRequest{
                Token:    "valid_fcm_token_123",
                Platform: "ANDROID",
                Device:   "Pixel 8",
            },
            valid: true,
        },
        {
            name: "valid ios voip token",
            request: &tokensv1.SaveTokenRequest{
                Token:     "valid_apns_token_456",
                Platform:  "IOS",
                Device:    "iPhone 15",
                TokenVoip: "valid_voip_token_789",
                IsVoip:    true,
            },
            valid: true,
        },
        {
            name: "invalid empty token",
            request: &tokensv1.SaveTokenRequest{
                Token:    "",
                Platform: "ANDROID",
            },
            valid: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := validateSaveTokenRequest(tt.request)
            if tt.valid {
                assert.NoError(t, err)
            } else {
                assert.Error(t, err)
            }
        })
    }
}
```

### Property-Based Testing

```go
func TestSaveTokenRequestProperties(t *testing.T) {
    quick.Check(func(token, platform, device string) bool {
        request := &tokensv1.SaveTokenRequest{
            Token:    token,
            Platform: platform,
            Device:   device,
        }
        
        // Propiedades que siempre deben cumplirse
        return request.GetToken() == token &&
               request.GetPlatform() == platform &&
               request.GetDevice() == device
    }, nil)
}
```

## Comparación con Chat Types

### Similitudes
- **Misma estructura**: Patrón idéntico de generación
- **Mismos métodos**: Reset, String, ProtoMessage, ProtoReflect
- **Mismos getters**: Null-safe getters con valores por defecto
- **Misma serialización**: JSON y binary Protocol Buffers

### Diferencias Clave

#### Complejidad
```go
// Chat Types
- 10+ estructuras complejas
- Enums (MessageStatus, SyncStrategy)
- Campos opcionales con punteros
- Relaciones entre tipos
- OneOf fields

// Tokens Types
- 2 estructuras simples
- Sin enums
- Todos los campos opcionales
- Sin relaciones complejas
- Sin OneOf fields
```

#### Casos de Uso
```go
// Chat Types - Múltiples casos de uso
- Mensajes de chat
- Gestión de salas
- Eventos en tiempo real
- Sincronización compleja

// Tokens Types - Caso de uso específico
- Solo registro de tokens
- Funcionalidad enfocada
- Sin eventos complejos
```

## Mejores Prácticas

1. **Validación**: Siempre validar datos antes de envío
2. **Null safety**: Usar getters en lugar de acceso directo
3. **Platform-specific**: Manejar diferencias entre plataformas
4. **Error handling**: Manejar errores de serialización
5. **Testing**: Testear todos los casos de plataforma
6. **Logging**: Log tokens de forma segura (sin exponer tokens completos)

## Consideraciones de Seguridad

### Manejo de Tokens
- **No logear tokens completos**: Solo primeros/últimos caracteres
- **Validar formato**: Verificar formato según plataforma
- **Rate limiting**: Limitar registros por usuario/IP
- **Expiración**: Manejar tokens expirados

### Ejemplo de Logging Seguro
```go
func logTokenSafely(token string) string {
    if len(token) < 10 {
        return "***"
    }
    return token[:5] + "..." + token[len(token)-5:]
}

log.Printf("Registering token: %s", logTokenSafely(request.GetToken()))
```

Este archivo proporciona tipos simples pero robustos para la gestión de tokens de dispositivos, manteniendo la calidad y características del framework de Protocol Buffers pero con una complejidad mucho menor que los tipos del servicio de chat.