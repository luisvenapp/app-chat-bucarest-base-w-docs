# Documentación Técnica: proto/generated/services/tokens/v1/client/tokensservice.client.go

## Descripción General

Este archivo es **código generado automáticamente** por `campaing-app-api-cli`, la herramienta personalizada del proyecto. Proporciona un cliente de alto nivel para el servicio de tokens que incluye las mismas funcionalidades avanzadas que el cliente de chat: pooling de conexiones, logging automático, manejo de protocolos HTTP/2 y HTTP/1.1, e integración con el sistema de parámetros generales. Aunque es más simple que el cliente de chat (solo un método), mantiene la misma arquitectura robusta.

## Estructura del Archivo

### Información de Generación

```go
// Code generated by campaing-app-api-cli. DO NOT EDIT.
//
// source: services/tokens/v1/service.proto
```

**Análisis:**
- **Herramienta personalizada**: Generado por `campaing-app-api-cli`
- **Fuente**: Basado en `services/tokens/v1/service.proto`
- **Prohibición de edición**: No debe modificarse manualmente

### Importaciones

```go
import (
    context "context"
    tls "crypto/tls"
    log "log"
    net "net"
    http "net/http"
    strings "strings"
    sync "sync"
    
    connect "connectrpc.com/connect"
    catalogs "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/catalogs"
    v1 "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/proto/generated/services/tokens/v1"
    tokensv1connect "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/proto/generated/services/tokens/v1/tokensv1connect"
    api "github.com/Venqis-NolaTech/campaing-app-core-go/pkg/api"
    http2 "golang.org/x/net/http2"
    protojson "google.golang.org/protobuf/encoding/protojson"
)
```

**Análisis de Dependencias:**

#### Librerías Estándar
- **`context`**: Manejo de contexto y cancelación
- **`crypto/tls`**: Configuración TLS para HTTPS
- **`log`**: Logging de requests y responses
- **`net`**: Operaciones de red de bajo nivel
- **`net/http`**: Cliente HTTP estándar
- **`strings`**: Manipulación de strings para URLs
- **`sync`**: Primitivas de sincronización para pooling

#### Librerías Externas
- **`connect`**: Framework ConnectRPC
- **`http2`**: Soporte para HTTP/2
- **`protojson`**: Serialización JSON de Protocol Buffers

#### Módulos Internos
- **`catalogs`**: Configuración de direcciones de servicios
- **`v1`**: Tipos generados de Protocol Buffers
- **`tokensv1connect`**: Cliente ConnectRPC generado
- **`api`**: Utilidades del core para requests

## Variables Globales y Pooling

### Sistema de Pooling de Clientes

```go
var (
    muTokensService            = sync.Mutex{}
    clientsTokensService       = map[string]tokensv1connect.TokensServiceClient{}
    h2cHttpTokensServiceClient = &http.Client{
        CheckRedirect: func(_ *http.Request, _ []*http.Request) error {
            return http.ErrUseLastResponse
        },
        Transport: &http2.Transport{
            AllowHTTP: true,
            DialTLS: func(network, addr string, _ *tls.Config) (net.Conn, error) {
                return net.Dial(network, addr)
            },
        },
    }
)
```

**Análisis Detallado:**

#### `muTokensService sync.Mutex`
- **Propósito**: Protege el acceso concurrente al pool de clientes
- **Thread Safety**: Garantiza operaciones atómicas en el map
- **Performance**: Evita race conditions en entornos concurrentes

#### `clientsTokensService map[string]tokensv1connect.TokensServiceClient`
- **Propósito**: Pool de clientes reutilizables por dirección
- **Clave**: Dirección del servidor (ej: "https://api.example.com")
- **Valor**: Cliente ConnectRPC configurado para tokens
- **Beneficio**: Reutilización de conexiones y configuración

#### `h2cHttpTokensServiceClient *http.Client`
- **Propósito**: Cliente HTTP/2 optimizado para conexiones no-TLS
- **H2C**: HTTP/2 Cleartext (sin TLS)
- **Uso**: Comunicación interna entre servicios

##### Configuración de Redirects
```go
CheckRedirect: func(_ *http.Request, _ []*http.Request) error {
    return http.ErrUseLastResponse
}
```
- **Comportamiento**: No sigue redirects automáticamente
- **Razón**: Control explícito sobre redirects en APIs
- **Seguridad**: Evita redirects maliciosos

##### Configuración de Transport
```go
Transport: &http2.Transport{
    AllowHTTP: true,
    DialTLS: func(network, addr string, _ *tls.Config) (net.Conn, error) {
        return net.Dial(network, addr)
    },
}
```

**Características:**
- **`AllowHTTP: true`**: Permite HTTP/2 sobre conexiones no-TLS
- **`DialTLS` personalizado**: Usa conexión TCP normal en lugar de TLS
- **Optimización**: Mejor performance para comunicación interna

## Función instanceNewTokensServiceClient

```go
func instanceNewTokensServiceClient(addr string) tokensv1connect.TokensServiceClient {
    client := h2cHttpTokensServiceClient
    if strings.HasPrefix(addr, "https://") {
        client = &http.Client{}
    }
    return tokensv1connect.NewTokensServiceClient(
        client,
        addr,
        connect.WithHTTPGet(),
    )
}
```

**Análisis del Proceso:**

### Selección de Cliente HTTP
```go
client := h2cHttpTokensServiceClient
if strings.HasPrefix(addr, "https://") {
    client = &http.Client{}
}
```

**Lógica:**
- **HTTP**: Usa cliente H2C optimizado para conexiones internas
- **HTTPS**: Usa cliente estándar con TLS para conexiones externas
- **Detección**: Basada en el prefijo de la URL

### Configuración del Cliente ConnectRPC
```go
return tokensv1connect.NewTokensServiceClient(
    client,
    addr,
    connect.WithHTTPGet(),
)
```

**Opciones:**
- **`connect.WithHTTPGet()`**: Habilita soporte para GET requests
- **Beneficio**: Permite requests idempotentes vía GET (aunque SaveToken usa POST)
- **Compatibilidad**: Mejor integración con proxies y caches

## Función GetTokensServiceClient

```go
func GetTokensServiceClient() tokensv1connect.TokensServiceClient {
    addr := catalogs.ClientAddress()
    var client tokensv1connect.TokensServiceClient
    muTokensService.Lock()
    defer muTokensService.Unlock()
    if c, ok := clientsTokensService[addr]; ok && c != nil {
        client = c
    } else {
        client = instanceNewTokensServiceClient(addr)
        clientsTokensService[addr] = client
    }
    return client
}
```

**Análisis del Patrón Singleton con Pool:**

### 1. Obtención de Dirección
```go
addr := catalogs.ClientAddress()
```
- **Configuración centralizada**: Dirección desde catálogos
- **Flexibilidad**: Puede cambiar según entorno
- **Consistencia**: Misma dirección en toda la aplicación

### 2. Sincronización
```go
muTokensService.Lock()
defer muTokensService.Unlock()
```
- **Thread Safety**: Protege acceso al pool
- **Defer**: Garantiza liberación del lock
- **Atomicidad**: Operación atómica de verificación y creación

### 3. Verificación de Cache
```go
if c, ok := clientsTokensService[addr]; ok && c != nil {
    client = c
}
```
- **Cache Hit**: Reutiliza cliente existente
- **Validación**: Verifica que el cliente no sea nil
- **Performance**: Evita creación innecesaria de clientes

### 4. Creación y Cache
```go
else {
    client = instanceNewTokensServiceClient(addr)
    clientsTokensService[addr] = client
}
```
- **Cache Miss**: Crea nuevo cliente
- **Almacenamiento**: Guarda en pool para reutilización
- **Lazy Loading**: Solo crea cuando se necesita

## Función SaveToken

```go
func SaveToken(ctx context.Context, generalParams api.GeneralParams, req *v1.SaveTokenRequest) (*v1.SaveTokenResponse, error) {
    jsonReq, _ := protojson.Marshal(req)
    log.Println("PROCESSING UNARY GRPC METHOD: services.tokens.v1.TokensService@SaveToken(v1.SaveTokenRequest) -> v1.SaveTokenResponse")
    log.Printf("UNARY GRPC REQUEST: v1.SaveTokenRequest -> %s\n", string(jsonReq))
    var response *v1.SaveTokenResponse
    rpcRequest, err := api.NewRequest(generalParams, req)
    if err != nil {
        return response, err
    }
    rpcResponse, err := GetTokensServiceClient().SaveToken(ctx, rpcRequest)
    if rpcResponse != nil {
        response = rpcResponse.Msg
        jsonRes, _ := protojson.Marshal(response)
        log.Printf("UNARY GRPC RESPONSE: v1.SaveTokenResponse -> %s\n", string(jsonRes))
    }
    return response, err
}
```

**Análisis Paso a Paso:**

### 1. Logging de Request
```go
jsonReq, _ := protojson.Marshal(req)
log.Println("PROCESSING UNARY GRPC METHOD: services.tokens.v1.TokensService@SaveToken(v1.SaveTokenRequest) -> v1.SaveTokenResponse")
log.Printf("UNARY GRPC REQUEST: v1.SaveTokenRequest -> %s\n", string(jsonReq))
```

**Características:**
- **Serialización JSON**: Convierte request a JSON para logging
- **Método identificado**: Log del método específico siendo llamado
- **Request completo**: Log del contenido del request
- **Debugging**: Facilita debugging y auditoría

### 2. Preparación de Request
```go
var response *v1.SaveTokenResponse
rpcRequest, err := api.NewRequest(generalParams, req)
if err != nil {
    return response, err
}
```

**Proceso:**
- **Inicialización**: Variable de response inicializada
- **Wrapper**: `api.NewRequest` envuelve el request con parámetros generales
- **Error Handling**: Manejo temprano de errores de preparación

#### Parámetros Generales Incluidos
```go
type GeneralParams struct {
    SessionToken string    // Token de autenticación
    Lang         string    // Idioma del usuario
    Platform     string    // Plataforma (web, mobile, etc.)
    IANATimezone string    // Zona horaria
    Session      *Session  // Datos de sesión
    ClientId     string    // ID único del cliente
}
```

### 3. Ejecución de RPC
```go
rpcResponse, err := GetTokensServiceClient().SaveToken(ctx, rpcRequest)
```

**Características:**
- **Cliente pooled**: Usa cliente del pool
- **Context propagation**: Propaga contexto para cancelación
- **Error propagation**: Propaga errores del cliente

### 4. Logging de Response
```go
if rpcResponse != nil {
    response = rpcResponse.Msg
    jsonRes, _ := protojson.Marshal(response)
    log.Printf("UNARY GRPC RESPONSE: v1.SaveTokenResponse -> %s\n", string(jsonRes))
}
```

**Proceso:**
- **Extracción**: Extrae mensaje de la respuesta ConnectRPC
- **Serialización**: Convierte response a JSON
- **Logging**: Log del contenido de la respuesta
- **Conditional**: Solo logea si hay respuesta válida

## Funcionalidad del Método SaveToken

### Propósito Principal
- **Registro de tokens**: Almacena tokens de notificaciones push
- **Actualización**: Permite actualizar tokens existentes
- **Múltiples dispositivos**: Un usuario puede tener múltiples tokens
- **Metadatos**: Incluye información del dispositivo y plataforma

### Plataformas Soportadas

#### Android (FCM)
```go
request := &v1.SaveTokenRequest{
    Token:           "fcm_token_abc123...",
    Platform:        "ANDROID",
    PlatformVersion: "14",
    Device:          "Samsung Galaxy S24",
    Lang:            "es",
    IsVoip:          false,
    Debug:           false,
}
```

#### iOS (APNS)
```go
request := &v1.SaveTokenRequest{
    Token:           "apns_token_def456...",
    Platform:        "IOS",
    PlatformVersion: "17.2",
    Device:          "iPhone 15 Pro",
    TokenVoip:       "voip_token_789...",
    IsVoip:          true,
    Lang:            "en",
    Debug:           false,
}
```

#### Web Push
```go
request := &v1.SaveTokenRequest{
    Token:           "web_push_token_ghi789...",
    Platform:        "WEB",
    PlatformVersion: "Chrome 120",
    Device:          "Desktop Chrome",
    Lang:            "fr",
    IsVoip:          false,
    Debug:           false,
}
```

## Uso Típico

### Ejemplo de Uso Básico

```go
// Configurar parámetros generales
generalParams := api.GeneralParams{
    SessionToken: "jwt_token_here",
    Lang:         "es",
    Platform:     "ANDROID",
    ClientId:     "client_123",
}

// Registrar token FCM
request := &v1.SaveTokenRequest{
    Token:           "fcm_token_abc123...",
    Platform:        "ANDROID",
    PlatformVersion: "14",
    Device:          "Samsung Galaxy S24",
    Lang:            "es",
    IsVoip:          false,
    Debug:           false,
}

response, err := tokensv1client.SaveToken(ctx, generalParams, request)
if err != nil {
    log.Printf("Error registrando token: %v", err)
    return
}

if response.GetSuccess() {
    log.Println("Token registrado exitosamente")
}
```

### Ejemplo con Context y Timeout

```go
// Context con timeout
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

// Registrar token con timeout
response, err := tokensv1client.SaveToken(ctx, generalParams, request)
if err != nil {
    if errors.Is(err, context.DeadlineExceeded) {
        log.Println("Timeout registrando token")
    } else {
        log.Printf("Error: %v", err)
    }
    return
}
```

### Manejo de Errores Específicos

```go
response, err := tokensv1client.SaveToken(ctx, generalParams, request)
if err != nil {
    if connectErr := new(connect.Error); errors.As(err, &connectErr) {
        switch connectErr.Code() {
        case connect.CodeUnauthenticated:
            log.Println("Token de autenticación inválido")
        case connect.CodeInvalidArgument:
            log.Println("Token de dispositivo inválido")
        case connect.CodeAlreadyExists:
            log.Println("Token ya registrado")
        default:
            log.Printf("Error desconocido: %v", connectErr)
        }
    }
    return
}
```

## Ventajas del Cliente Generado

### 1. **Logging Automático**
- **Request/Response**: Log completo de todas las operaciones
- **Debugging**: Facilita debugging y troubleshooting
- **Auditoría**: Rastro completo de operaciones

### 2. **Pooling de Conexiones**
- **Reutilización**: Clientes reutilizables por dirección
- **Performance**: Evita overhead de creación
- **Thread Safety**: Acceso seguro concurrente

### 3. **Protocolo Inteligente**
- **HTTP/HTTPS**: Detección automática de protocolo
- **H2C**: Optimización para comunicación interna
- **Flexibilidad**: Adaptación automática al entorno

### 4. **Integración con Core**
- **GeneralParams**: Integración con sistema de parámetros
- **Autenticación**: Manejo automático de tokens
- **Configuración**: Uso de catálogos centralizados

### 5. **Type Safety**
- **Request tipado**: Validación en tiempo de compilación
- **Response tipado**: Acceso seguro a campos
- **Error handling**: Manejo robusto de errores

## Comparación con Chat Client

### Similitudes
- **Misma arquitectura**: Patrón idéntico de pooling y logging
- **Mismas optimizaciones**: H2C, HTTP/2, connection reuse
- **Misma integración**: GeneralParams, catalogs, core API
- **Mismo logging**: Formato idéntico de logs

### Diferencias
- **Simplicidad**: Un solo método vs múltiples métodos
- **Funcionalidad**: Específica vs general
- **Complejidad**: Más simple de mantener
- **Pool size**: Menor uso de memoria

## Consideraciones de Performance

### 1. **Connection Pooling**
- **Reutilización**: Cliente reutilizado por dirección
- **Overhead**: Reducción significativa de overhead
- **Memory**: Uso eficiente de memoria

### 2. **HTTP/2 Optimization**
- **Multiplexing**: Múltiples requests en una conexión
- **Header compression**: Compresión de headers
- **Eficiencia**: Mejor para requests frecuentes

### 3. **Logging Overhead**
- **JSON marshaling**: Overhead de serialización para logs
- **I/O**: Overhead de escritura de logs
- **Configuración**: Debería ser configurable en producción

## Mejores Prácticas

1. **Reutilizar cliente**: Usar `GetTokensServiceClient()` en lugar de crear nuevos
2. **Context con timeout**: Siempre usar context con timeout apropiado
3. **Error handling**: Manejar errores específicos de ConnectRPC
4. **Logging**: Considerar nivel de logging en producción
5. **Parámetros generales**: Reutilizar parámetros cuando sea posible
6. **Validación**: Validar tokens antes de envío
7. **Rate limiting**: Implementar rate limiting para prevenir abuso

## Casos de Uso Específicos

### Registro en Login
```go
func registerDeviceToken(userID string, deviceToken string, platform string) error {
    generalParams := api.GeneralParams{
        SessionToken: getUserToken(userID),
        Lang:         getUserLanguage(userID),
        Platform:     platform,
        ClientId:     generateClientID(),
    }
    
    request := &v1.SaveTokenRequest{
        Token:           deviceToken,
        Platform:        platform,
        PlatformVersion: getOSVersion(),
        Device:          getDeviceModel(),
        Lang:            getUserLanguage(userID),
        Debug:           isDebugMode(),
    }
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    response, err := tokensv1client.SaveToken(ctx, generalParams, request)
    if err != nil {
        return fmt.Errorf("failed to register token: %w", err)
    }
    
    if !response.GetSuccess() {
        return errors.New("token registration failed")
    }
    
    return nil
}
```

### Actualización de Token
```go
func updateDeviceToken(oldToken, newToken string) error {
    // Registrar nuevo token
    err := registerDeviceToken(getCurrentUserID(), newToken, getCurrentPlatform())
    if err != nil {
        return fmt.Errorf("failed to register new token: %w", err)
    }
    
    // El servidor debería manejar la limpieza del token anterior
    log.Printf("Token updated from %s to %s", oldToken[:10]+"...", newToken[:10]+"...")
    
    return nil
}
```

Este cliente generado proporciona una interfaz simple pero robusta para la gestión de tokens de dispositivos, manteniendo la misma calidad y características avanzadas del cliente de chat pero con una funcionalidad más específica y enfocada.