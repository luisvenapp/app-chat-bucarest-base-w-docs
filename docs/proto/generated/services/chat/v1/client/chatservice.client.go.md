# Documentación Técnica: proto/generated/services/chat/v1/client/chatservice.client.go

## Descripción General

Este archivo es **código generado automáticamente** por `campaing-app-api-cli`, una herramienta personalizada del proyecto. Proporciona un cliente de alto nivel para el servicio de chat que incluye funcionalidades avanzadas como pooling de conexiones, logging automático, manejo de protocolos HTTP/2 y HTTP/1.1, y integración con el sistema de parámetros generales de la aplicación.

## Estructura del Archivo

### Información de Generación

```go
// Code generated by campaing-app-api-cli. DO NOT EDIT.
//
// source: services/chat/v1/service.proto
```

**Análisis:**
- **Herramienta personalizada**: Generado por `campaing-app-api-cli` (no herramienta estándar)
- **Fuente**: Basado en `services/chat/v1/service.proto`
- **Prohibición de edición**: No debe modificarse manualmente

### Importaciones

```go
import (
    context "context"
    tls "crypto/tls"
    log "log"
    net "net"
    http "net/http"
    strings "strings"
    sync "sync"
    
    connect "connectrpc.com/connect"
    catalogs "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/catalogs"
    v1 "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/proto/generated/services/chat/v1"
    chatv1connect "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/proto/generated/services/chat/v1/chatv1connect"
    api "github.com/Venqis-NolaTech/campaing-app-core-go/pkg/api"
    http2 "golang.org/x/net/http2"
    protojson "google.golang.org/protobuf/encoding/protojson"
)
```

**Análisis de Dependencias:**

#### Librerías Estándar
- **`context`**: Manejo de contexto y cancelación
- **`crypto/tls`**: Configuración TLS para HTTPS
- **`log`**: Logging de requests y responses
- **`net`**: Operaciones de red de bajo nivel
- **`net/http`**: Cliente HTTP estándar
- **`strings`**: Manipulación de strings para URLs
- **`sync`**: Primitivas de sincronización para pooling

#### Librerías Externas
- **`connect`**: Framework ConnectRPC
- **`http2`**: Soporte para HTTP/2
- **`protojson`**: Serialización JSON de Protocol Buffers

#### Módulos Internos
- **`catalogs`**: Configuración de direcciones de servicios
- **`v1`**: Tipos generados de Protocol Buffers
- **`chatv1connect`**: Cliente ConnectRPC generado
- **`api`**: Utilidades del core para requests

## Variables Globales y Pooling

### Sistema de Pooling de Clientes

```go
var (
    muChatService            = sync.Mutex{}
    clientsChatService       = map[string]chatv1connect.ChatServiceClient{}
    h2cHttpChatServiceClient = &http.Client{
        CheckRedirect: func(_ *http.Request, _ []*http.Request) error {
            return http.ErrUseLastResponse
        },
        Transport: &http2.Transport{
            AllowHTTP: true,
            DialTLS: func(network, addr string, _ *tls.Config) (net.Conn, error) {
                return net.Dial(network, addr)
            },
        },
    }
)
```

**Análisis Detallado:**

#### `muChatService sync.Mutex`
- **Propósito**: Protege el acceso concurrente al pool de clientes
- **Thread Safety**: Garantiza operaciones atómicas en el map
- **Performance**: Evita race conditions en entornos concurrentes

#### `clientsChatService map[string]chatv1connect.ChatServiceClient`
- **Propósito**: Pool de clientes reutilizables por dirección
- **Clave**: Dirección del servidor (ej: "https://api.example.com")
- **Valor**: Cliente ConnectRPC configurado
- **Beneficio**: Reutilización de conexiones y configuración

#### `h2cHttpChatServiceClient *http.Client`
- **Propósito**: Cliente HTTP/2 optimizado para conexiones no-TLS
- **H2C**: HTTP/2 Cleartext (sin TLS)
- **Uso**: Comunicación interna entre servicios

##### Configuración de Redirects
```go
CheckRedirect: func(_ *http.Request, _ []*http.Request) error {
    return http.ErrUseLastResponse
}
```
- **Comportamiento**: No sigue redirects automáticamente
- **Razón**: Control explícito sobre redirects en APIs
- **Seguridad**: Evita redirects maliciosos

##### Configuración de Transport
```go
Transport: &http2.Transport{
    AllowHTTP: true,
    DialTLS: func(network, addr string, _ *tls.Config) (net.Conn, error) {
        return net.Dial(network, addr)
    },
}
```

**Características:**
- **`AllowHTTP: true`**: Permite HTTP/2 sobre conexiones no-TLS
- **`DialTLS` personalizado**: Usa conexión TCP normal en lugar de TLS
- **Optimización**: Mejor performance para comunicación interna

## Función instanceNewChatServiceClient

```go
func instanceNewChatServiceClient(addr string) chatv1connect.ChatServiceClient {
    client := h2cHttpChatServiceClient
    if strings.HasPrefix(addr, "https://") {
        client = &http.Client{}
    }
    return chatv1connect.NewChatServiceClient(
        client,
        addr,
        connect.WithHTTPGet(),
    )
}
```

**Análisis del Proceso:**

### Selección de Cliente HTTP
```go
client := h2cHttpChatServiceClient
if strings.HasPrefix(addr, "https://") {
    client = &http.Client{}
}
```

**Lógica:**
- **HTTP**: Usa cliente H2C optimizado para conexiones internas
- **HTTPS**: Usa cliente estándar con TLS para conexiones externas
- **Detección**: Basada en el prefijo de la URL

### Configuración del Cliente ConnectRPC
```go
return chatv1connect.NewChatServiceClient(
    client,
    addr,
    connect.WithHTTPGet(),
)
```

**Opciones:**
- **`connect.WithHTTPGet()`**: Habilita soporte para GET requests
- **Beneficio**: Permite requests idempotentes vía GET
- **Compatibilidad**: Mejor integración con proxies y caches

## Función GetChatServiceClient

```go
func GetChatServiceClient() chatv1connect.ChatServiceClient {
    addr := catalogs.ClientAddress()
    var client chatv1connect.ChatServiceClient
    muChatService.Lock()
    defer muChatService.Unlock()
    if c, ok := clientsChatService[addr]; ok && c != nil {
        client = c
    } else {
        client = instanceNewChatServiceClient(addr)
        clientsChatService[addr] = client
    }
    return client
}
```

**Análisis del Patrón Singleton con Pool:**

### 1. Obtención de Dirección
```go
addr := catalogs.ClientAddress()
```
- **Configuración centralizada**: Dirección desde catálogos
- **Flexibilidad**: Puede cambiar según entorno
- **Consistencia**: Misma dirección en toda la aplicación

### 2. Sincronización
```go
muChatService.Lock()
defer muChatService.Unlock()
```
- **Thread Safety**: Protege acceso al pool
- **Defer**: Garantiza liberación del lock
- **Atomicidad**: Operación atómica de verificación y creación

### 3. Verificación de Cache
```go
if c, ok := clientsChatService[addr]; ok && c != nil {
    client = c
}
```
- **Cache Hit**: Reutiliza cliente existente
- **Validación**: Verifica que el cliente no sea nil
- **Performance**: Evita creación innecesaria de clientes

### 4. Creación y Cache
```go
else {
    client = instanceNewChatServiceClient(addr)
    clientsChatService[addr] = client
}
```
- **Cache Miss**: Crea nuevo cliente
- **Almacenamiento**: Guarda en pool para reutilización
- **Lazy Loading**: Solo crea cuando se necesita

## Funciones de Wrapper para Métodos RPC

### Patrón de Implementación

Cada método RPC sigue el mismo patrón. Analicemos `SendMessage` como ejemplo:

```go
func SendMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.SendMessageRequest) (*v1.SendMessageResponse, error) {
    jsonReq, _ := protojson.Marshal(req)
    log.Println("PROCESSING UNARY GRPC METHOD: services.chat.v1.ChatService@SendMessage(v1.SendMessageRequest) -> v1.SendMessageResponse")
    log.Printf("UNARY GRPC REQUEST: v1.SendMessageRequest -> %s\n", string(jsonReq))
    var response *v1.SendMessageResponse
    rpcRequest, err := api.NewRequest(generalParams, req)
    if err != nil {
        return response, err
    }
    rpcResponse, err := GetChatServiceClient().SendMessage(ctx, rpcRequest)
    if rpcResponse != nil {
        response = rpcResponse.Msg
        jsonRes, _ := protojson.Marshal(response)
        log.Printf("UNARY GRPC RESPONSE: v1.SendMessageResponse -> %s\n", string(jsonRes))
    }
    return response, err
}
```

**Análisis Paso a Paso:**

### 1. Logging de Request
```go
jsonReq, _ := protojson.Marshal(req)
log.Println("PROCESSING UNARY GRPC METHOD: services.chat.v1.ChatService@SendMessage(v1.SendMessageRequest) -> v1.SendMessageResponse")
log.Printf("UNARY GRPC REQUEST: v1.SendMessageRequest -> %s\n", string(jsonReq))
```

**Características:**
- **Serialización JSON**: Convierte request a JSON para logging
- **Método identificado**: Log del método específico siendo llamado
- **Request completo**: Log del contenido del request
- **Debugging**: Facilita debugging y auditoría

### 2. Preparación de Request
```go
var response *v1.SendMessageResponse
rpcRequest, err := api.NewRequest(generalParams, req)
if err != nil {
    return response, err
}
```

**Proceso:**
- **Inicialización**: Variable de response inicializada
- **Wrapper**: `api.NewRequest` envuelve el request con parámetros generales
- **Error Handling**: Manejo temprano de errores de preparación

#### Parámetros Generales Incluidos
```go
type GeneralParams struct {
    SessionToken string    // Token de autenticación
    Lang         string    // Idioma del usuario
    Platform     string    // Plataforma (web, mobile, etc.)
    IANATimezone string    // Zona horaria
    Session      *Session  // Datos de sesión
    ClientId     string    // ID único del cliente
}
```

### 3. Ejecución de RPC
```go
rpcResponse, err := GetChatServiceClient().SendMessage(ctx, rpcRequest)
```

**Características:**
- **Cliente pooled**: Usa cliente del pool
- **Context propagation**: Propaga contexto para cancelación
- **Error propagation**: Propaga errores del cliente

### 4. Logging de Response
```go
if rpcResponse != nil {
    response = rpcResponse.Msg
    jsonRes, _ := protojson.Marshal(response)
    log.Printf("UNARY GRPC RESPONSE: v1.SendMessageResponse -> %s\n", string(jsonRes))
}
```

**Proceso:**
- **Extracción**: Extrae mensaje de la respuesta ConnectRPC
- **Serialización**: Convierte response a JSON
- **Logging**: Log del contenido de la respuesta
- **Conditional**: Solo logea si hay respuesta válida

## Métodos Implementados

### Gestión de Mensajes

#### `SendMessage`
```go
func SendMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.SendMessageRequest) (*v1.SendMessageResponse, error)
```
- **Propósito**: Enviar nuevo mensaje a una sala
- **Parámetros**: Contexto, parámetros generales, request tipado
- **Retorno**: Response tipado con información del mensaje enviado

#### `EditMessage`
```go
func EditMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.EditMessageRequest) (*v1.EditMessageResponse, error)
```
- **Propósito**: Editar mensaje existente
- **Restricciones**: Solo el autor puede editar
- **Historial**: Mantiene historial de ediciones

#### `DeleteMessage`
```go
func DeleteMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.DeleteMessageRequest) (*v1.DeleteMessageResponse, error)
```
- **Propósito**: Eliminar mensaje
- **Comportamiento**: Soft delete preservando historial
- **Permisos**: Autor o administrador de sala

#### `ReactToMessage`
```go
func ReactToMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.ReactToMessageRequest) (*v1.ReactToMessageResponse, error)
```
- **Propósito**: Agregar reacción emoji a mensaje
- **Limitación**: Una reacción por usuario por mensaje
- **Actualización**: Reemplaza reacción existente

### Gestión de Salas

#### `GetRooms`
```go
func GetRooms(ctx context.Context, generalParams api.GeneralParams, req *v1.GetRoomsRequest) (*v1.GetRoomsResponse, error)
```
- **Propósito**: Listar salas del usuario
- **Paginación**: Soporte completo para paginación
- **Ordenamiento**: Por actividad reciente, salas pinned primero

#### `CreateRoom`
```go
func CreateRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.CreateRoomRequest) (*v1.CreateRoomResponse, error)
```
- **Propósito**: Crear nueva sala de chat
- **Tipos**: P2P (persona a persona) o grupo
- **Permisos**: Creador se convierte en owner automáticamente

#### `GetRoom`
```go
func GetRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.GetRoomRequest) (*v1.GetRoomResponse, error)
```
- **Propósito**: Obtener detalles de sala específica
- **Autorización**: Solo miembros pueden acceder
- **Información**: Metadatos completos de la sala

#### `UpdateRoom`
```go
func UpdateRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.UpdateRoomRequest) (*v1.UpdateRoomResponse, error)
```
- **Propósito**: Actualizar configuración de sala
- **Permisos**: Solo owners y admins
- **Campos**: Nombre, descripción, imagen, permisos

### Gestión de Participantes

#### `GetRoomParticipants`
```go
func GetRoomParticipants(ctx context.Context, generalParams api.GeneralParams, req *v1.GetRoomParticipantsRequest) (*v1.GetRoomParticipantsResponse, error)
```
- **Propósito**: Listar participantes de una sala
- **Paginación**: Soporte para salas con muchos miembros
- **Información**: Roles, estado, fecha de unión

#### `AddParticipantToRoom`
```go
func AddParticipantToRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.AddParticipantToRoomRequest) (*v1.AddParticipantToRoomResponse, error)
```
- **Propósito**: Agregar nuevos participantes
- **Permisos**: Según configuración de la sala
- **Batch**: Permite agregar múltiples usuarios

#### `UpdateParticipantRoom`
```go
func UpdateParticipantRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.UpdateParticipantRoomRequest) (*v1.UpdateParticipantRoomResponse, error)
```
- **Propósito**: Modificar rol de participante
- **Roles**: Owner, Admin, Member
- **Restricciones**: Solo owners pueden cambiar roles

#### `LeaveRoom`
```go
func LeaveRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.LeaveRoomRequest) (*v1.LeaveRoomResponse, error)
```
- **Propósito**: Salir de sala o remover participantes
- **Flexibilidad**: Auto-salida o remoción de otros
- **Cleanup**: Limpieza automática de datos relacionados

### Funcionalidades Avanzadas

#### `PinRoom`
```go
func PinRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.PinRoomRequest) (*v1.PinRoomResponse, error)
```
- **Propósito**: Fijar/desfijar sala en lista del usuario
- **UI**: Salas fijadas aparecen primero
- **Personal**: Configuración personal por usuario

#### `MuteRoom`
```go
func MuteRoom(ctx context.Context, generalParams api.GeneralParams, req *v1.MuteRoomRequest) (*v1.MuteRoomResponse, error)
```
- **Propósito**: Silenciar/activar notificaciones
- **Granularidad**: Por sala individual
- **Persistencia**: Configuración persistente

#### `BlockUser`
```go
func BlockUser(ctx context.Context, generalParams api.GeneralParams, req *v1.BlockUserRequest) (*v1.BlockUserResponse, error)
```
- **Propósito**: Bloquear/desbloquear usuario en chat P2P
- **Efecto**: Previene envío de mensajes
- **Bidireccional**: Afecta comunicación en ambas direcciones

### Consultas y Historial

#### `GetMessageHistory`
```go
func GetMessageHistory(ctx context.Context, generalParams api.GeneralParams, req *v1.GetMessageHistoryRequest) (*v1.GetMessageHistoryResponse, error)
```
- **Propósito**: Obtener historial de mensajes
- **Paginación**: Soporte para historial largo
- **Filtrado**: Por fecha, tipo, usuario

#### `GetMessage`
```go
func GetMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.GetMessageRequest) (*v1.MessageData, error)
```
- **Propósito**: Obtener mensaje específico
- **Autorización**: Solo miembros de la sala
- **Detalles**: Información completa del mensaje

#### `GetSenderMessage`
```go
func GetSenderMessage(ctx context.Context, generalParams api.GeneralParams, req *v1.GetSenderMessageRequest) (*v1.GetSenderMessageResponse, error)
```
- **Propósito**: Obtener mensaje por ID del cliente
- **Idempotencia**: Para evitar duplicados
- **Lookup**: Búsqueda por sender_message_id

#### `GetMessageRead`
```go
func GetMessageRead(ctx context.Context, generalParams api.GeneralParams, req *v1.GetMessageReadRequest) (*v1.GetMessageReadResponse, error)
```
- **Propósito**: Obtener información de lectura
- **Uso**: Mostrar "visto por" en grupos
- **Privacidad**: Solo en salas donde el usuario es miembro

#### `GetMessageReactions`
```go
func GetMessageReactions(ctx context.Context, generalParams api.GeneralParams, req *v1.GetMessageReactionsRequest) (*v1.GetMessageReactionsResponse, error)
```
- **Propósito**: Obtener reacciones de un mensaje
- **Agrupación**: Por tipo de reacción
- **Usuarios**: Lista de usuarios que reaccionaron

#### `MarkMessagesAsRead`
```go
func MarkMessagesAsRead(ctx context.Context, generalParams api.GeneralParams, req *v1.MarkMessagesAsReadRequest) (*v1.MarkMessagesAsReadResponse, error)
```
- **Propósito**: Marcar mensajes como leídos
- **Batch**: Múltiples mensajes en una operación
- **Estado**: Actualiza estado de lectura

#### `InitialSync`
```go
func InitialSync(ctx context.Context, generalParams api.GeneralParams, req *v1.InitialSyncRequest) (*v1.InitialSyncResponse, error)
```
- **Propósito**: Sincronización inicial completa
- **Uso**: Primera carga de la aplicación
- **Optimización**: Datos agregados en una respuesta

## Ventajas del Cliente Generado

### 1. **Logging Automático**
- **Request/Response**: Log completo de todas las operaciones
- **Debugging**: Facilita debugging y troubleshooting
- **Auditoría**: Rastro completo de operaciones

### 2. **Pooling de Conexiones**
- **Reutilización**: Clientes reutilizables por dirección
- **Performance**: Evita overhead de creación
- **Thread Safety**: Acceso seguro concurrente

### 3. **Protocolo Inteligente**
- **HTTP/HTTPS**: Detección automática de protocolo
- **H2C**: Optimización para comunicación interna
- **Flexibilidad**: Adaptación automática al entorno

### 4. **Integración con Core**
- **GeneralParams**: Integración con sistema de parámetros
- **Autenticación**: Manejo automático de tokens
- **Configuración**: Uso de catálogos centralizados

### 5. **Type Safety**
- **Requests tipados**: Validación en tiempo de compilación
- **Responses tipados**: Acceso seguro a campos
- **Error handling**: Manejo robusto de errores

## Uso Típico

### Ejemplo de Uso Básico

```go
// Configurar parámetros generales
generalParams := api.GeneralParams{
    SessionToken: "jwt_token_here",
    Lang:         "es",
    Platform:     "web",
    ClientId:     "client_123",
}

// Enviar mensaje
request := &v1.SendMessageRequest{
    RoomId:  "room_456",
    Content: "Hola mundo!",
    Type:    "user_message",
}

response, err := chatv1client.SendMessage(ctx, generalParams, request)
if err != nil {
    log.Printf("Error enviando mensaje: %v", err)
    return
}

log.Printf("Mensaje enviado: %s", response.Message.Id)
```

### Ejemplo con Context y Timeout

```go
// Context con timeout
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

// Obtener salas
request := &v1.GetRoomsRequest{
    Limit:  20,
    Offset: 0,
}

response, err := chatv1client.GetRooms(ctx, generalParams, request)
if err != nil {
    log.Printf("Error obteniendo salas: %v", err)
    return
}

log.Printf("Encontradas %d salas", len(response.Items))
```

## Consideraciones de Performance

### 1. **Connection Pooling**
- **Reutilización**: Clientes reutilizados por dirección
- **Overhead**: Reducción significativa de overhead
- **Memory**: Uso eficiente de memoria

### 2. **HTTP/2 Optimization**
- **Multiplexing**: Múltiples requests en una conexión
- **Header compression**: Compresión de headers
- **Server push**: Soporte para server push

### 3. **Logging Overhead**
- **JSON marshaling**: Overhead de serialización para logs
- **I/O**: Overhead de escritura de logs
- **Configuración**: Debería ser configurable en producción

## Mejores Prácticas

1. **Reutilizar cliente**: Usar `GetChatServiceClient()` en lugar de crear nuevos
2. **Context con timeout**: Siempre usar context con timeout apropiado
3. **Error handling**: Manejar errores específicos de ConnectRPC
4. **Logging**: Considerar nivel de logging en producción
5. **Parámetros generales**: Reutilizar parámetros cuando sea posible

Este cliente generado proporciona una interfaz de alto nivel, optimizada y con características avanzadas para interactuar con el servicio de chat de manera eficiente y robusta.