# Documentación Técnica: proto/generated/services/chat/v1/chatv1connect/service.connect.go

## Descripción General

Este archivo es **código generado automáticamente** por `protoc-gen-connect-go` a partir del archivo `services/chat/v1/service.proto`. Implementa las interfaces y clientes ConnectRPC para el servicio de chat, proporcionando soporte completo para gRPC, gRPC-Web y el protocolo Connect. Es el núcleo de la comunicación entre clientes y servidor para todas las operaciones de chat.

## Estructura del Archivo

### Información de Generación

```go
// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: services/chat/v1/service.proto
```

**Análisis:**
- **Generación automática**: No debe editarse manualmente
- **Fuente**: Generado desde `services/chat/v1/service.proto`
- **Herramienta**: `protoc-gen-connect-go` del ecosistema ConnectRPC

### Importaciones

```go
import (
    connect "connectrpc.com/connect"
    context "context"
    errors "errors"
    v1 "github.com/Venqis-NolaTech/campaing-app-chat-messages-api-go/proto/generated/services/chat/v1"
    http "net/http"
    strings "strings"
)
```

**Análisis de Dependencias:**
- **`connect`**: Framework ConnectRPC para servicios gRPC-Web
- **`context`**: Manejo de contexto y cancelación
- **`errors`**: Creación de errores estándar
- **`v1`**: Tipos de datos generados desde Protocol Buffers
- **`http`**: Servidor HTTP estándar
- **`strings`**: Manipulación de strings para URLs

### Verificación de Compatibilidad

```go
const _ = connect.IsAtLeastVersion1_13_0
```

**Propósito:**
- **Verificación en tiempo de compilación**: Asegura compatibilidad de versiones
- **Prevención de errores**: Evita incompatibilidades entre versiones
- **Versión mínima**: Requiere ConnectRPC v1.13.0 o superior

## Constantes de Servicio

### Nombre del Servicio

```go
const (
    // ChatServiceName is the fully-qualified name of the ChatService service.
    ChatServiceName = "services.chat.v1.ChatService"
)
```

**Análisis:**
- **Nombre completo**: Identificador único del servicio en el ecosistema
- **Formato**: `package.service` siguiendo convenciones de Protocol Buffers
- **Uso**: Registro de servicios, métricas, logging

### Procedimientos RPC

```go
const (
    // ChatServiceSendMessageProcedure is the fully-qualified name of the ChatService's SendMessage RPC.
    ChatServiceSendMessageProcedure = "/services.chat.v1.ChatService/SendMessage"
    // ChatServiceEditMessageProcedure is the fully-qualified name of the ChatService's EditMessage RPC.
    ChatServiceEditMessageProcedure = "/services.chat.v1.ChatService/EditMessage"
    // ... (continúa con todos los métodos)
)
```

**Análisis de Procedimientos:**

#### Formato de Procedimientos
- **Patrón**: `/package.service/Method`
- **Uso**: Rutas HTTP para gRPC-Web y Connect
- **Identificación**: Nombres únicos para cada operación

#### Categorización de Operaciones

##### **Gestión de Mensajes**
```go
ChatServiceSendMessageProcedure      = "/services.chat.v1.ChatService/SendMessage"
ChatServiceEditMessageProcedure     = "/services.chat.v1.ChatService/EditMessage"
ChatServiceDeleteMessageProcedure   = "/services.chat.v1.ChatService/DeleteMessage"
ChatServiceReactToMessageProcedure  = "/services.chat.v1.ChatService/ReactToMessage"
```

##### **Gestión de Salas**
```go
ChatServiceGetRoomsProcedure         = "/services.chat.v1.ChatService/GetRooms"
ChatServiceCreateRoomProcedure       = "/services.chat.v1.ChatService/CreateRoom"
ChatServiceGetRoomProcedure          = "/services.chat.v1.ChatService/GetRoom"
ChatServiceUpdateRoomProcedure       = "/services.chat.v1.ChatService/UpdateRoom"
```

##### **Gestión de Participantes**
```go
ChatServiceGetRoomParticipantsProcedure    = "/services.chat.v1.ChatService/GetRoomParticipants"
ChatServiceAddParticipantToRoomProcedure   = "/services.chat.v1.ChatService/AddParticipantToRoom"
ChatServiceUpdateParticipantRoomProcedure  = "/services.chat.v1.ChatService/UpdateParticipantRoom"
ChatServiceLeaveRoomProcedure              = "/services.chat.v1.ChatService/LeaveRoom"
```

##### **Funcionalidades Avanzadas**
```go
ChatServicePinRoomProcedure                = "/services.chat.v1.ChatService/PinRoom"
ChatServiceMuteRoomProcedure               = "/services.chat.v1.ChatService/MuteRoom"
ChatServiceBlockUserProcedure              = "/services.chat.v1.ChatService/BlockUser"
ChatServiceMarkMessagesAsReadProcedure     = "/services.chat.v1.ChatService/MarkMessagesAsRead"
```

##### **Consultas y Sincronización**
```go
ChatServiceGetMessageHistoryProcedure     = "/services.chat.v1.ChatService/GetMessageHistory"
ChatServiceGetMessageProcedure            = "/services.chat.v1.ChatService/GetMessage"
ChatServiceGetMessageReadProcedure        = "/services.chat.v1.ChatService/GetMessageRead"
ChatServiceGetMessageReactionsProcedure   = "/services.chat.v1.ChatService/GetMessageReactions"
ChatServiceInitialSyncProcedure           = "/services.chat.v1.ChatService/InitialSync"
```

##### **Streaming en Tiempo Real**
```go
ChatServiceStreamMessagesProcedure        = "/services.chat.v1.ChatService/StreamMessages"
```

## Interface ChatServiceClient

```go
type ChatServiceClient interface {
    // Enviar mensaje
    // 🔒 Need private token to access this endpoint
    SendMessage(context.Context, *connect.Request[v1.SendMessageRequest]) (*connect.Response[v1.SendMessageResponse], error)
    
    // Editar mensaje existente
    // 🔒 Need private token to access this endpoint
    EditMessage(context.Context, *connect.Request[v1.EditMessageRequest]) (*connect.Response[v1.EditMessageResponse], error)
    
    // ... (continúa con todos los métodos)
}
```

**Análisis de la Interface:**

### Características Generales
- **Autenticación**: Todos los métodos requieren token privado (🔒)
- **Context-aware**: Todos los métodos reciben `context.Context`
- **Type Safety**: Uso de generics para requests y responses tipados
- **Error Handling**: Retorno explícito de errores

### Patrones de Métodos

#### Métodos Unary (Request-Response)
```go
SendMessage(context.Context, *connect.Request[v1.SendMessageRequest]) (*connect.Response[v1.SendMessageResponse], error)
```

**Estructura:**
- **Input**: `*connect.Request[RequestType]`
- **Output**: `*connect.Response[ResponseType], error`
- **Uso**: Operaciones síncronas simples

#### Métodos de Streaming
```go
StreamMessages(context.Context, *connect.Request[v1.StreamMessagesRequest]) (*connect.ServerStreamForClient[v1.MessageEvent], error)
```

**Estructura:**
- **Input**: `*connect.Request[RequestType]`
- **Output**: `*connect.ServerStreamForClient[EventType], error`
- **Uso**: Streaming unidireccional del servidor al cliente

### Documentación de Métodos

#### Gestión de Mensajes

##### `SendMessage`
- **Propósito**: Enviar nuevo mensaje a una sala
- **Autenticación**: Requerida
- **Tipo**: Unary
- **Uso**: Comunicación básica de chat

##### `EditMessage`
- **Propósito**: Editar mensaje existente
- **Autenticación**: Requerida
- **Restricciones**: Solo el autor puede editar

##### `DeleteMessage`
- **Propósito**: Eliminar mensaje
- **Autenticación**: Requerida
- **Comportamiento**: Soft delete preservando historial

##### `ReactToMessage`
- **Propósito**: Agregar reacción emoji a mensaje
- **Autenticación**: Requerida
- **Limitación**: Una reacción por usuario por mensaje

#### Gestión de Salas

##### `GetRooms`
- **Propósito**: Listar salas del usuario
- **Autenticación**: Requerida
- **Paginación**: Soportada
- **Ordenamiento**: Por actividad reciente

##### `CreateRoom`
- **Propósito**: Crear nueva sala de chat
- **Autenticación**: Requerida
- **Tipos**: P2P o grupo
- **Permisos**: Creador se convierte en owner

##### `GetRoom`
- **Propósito**: Obtener detalles de sala específica
- **Autenticación**: Requerida
- **Autorización**: Solo miembros de la sala

#### Streaming

##### `StreamMessages`
- **Propósito**: Recibir eventos de chat en tiempo real
- **Autenticación**: Requerida
- **Tipo**: Server streaming
- **Eventos**: Mensajes, estados, notificaciones

## Función NewChatServiceClient

```go
func NewChatServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ChatServiceClient {
    baseURL = strings.TrimRight(baseURL, "/")
    chatServiceMethods := v1.File_services_chat_v1_service_proto.Services().ByName("ChatService").Methods()
    return &chatServiceClient{
        sendMessage: connect.NewClient[v1.SendMessageRequest, v1.SendMessageResponse](
            httpClient,
            baseURL+ChatServiceSendMessageProcedure,
            connect.WithSchema(chatServiceMethods.ByName("SendMessage")),
            connect.WithClientOptions(opts...),
        ),
        // ... (continúa con todos los métodos)
    }
}
```

**Análisis de la Función:**

### Parámetros
- **`httpClient`**: Cliente HTTP para realizar requests
- **`baseURL`**: URL base del servidor (ej: `https://api.example.com`)
- **`opts`**: Opciones adicionales de configuración

### Proceso de Construcción

#### 1. Normalización de URL
```go
baseURL = strings.TrimRight(baseURL, "/")
```
- **Propósito**: Elimina slash final para evitar URLs malformadas
- **Resultado**: URLs consistentes

#### 2. Obtención de Metadata
```go
chatServiceMethods := v1.File_services_chat_v1_service_proto.Services().ByName("ChatService").Methods()
```
- **Propósito**: Obtiene metadata de métodos desde Protocol Buffers
- **Uso**: Configuración de schema para validación

#### 3. Creación de Clientes Individuales
```go
sendMessage: connect.NewClient[v1.SendMessageRequest, v1.SendMessageResponse](
    httpClient,
    baseURL+ChatServiceSendMessageProcedure,
    connect.WithSchema(chatServiceMethods.ByName("SendMessage")),
    connect.WithClientOptions(opts...),
),
```

**Características:**
- **Type Safety**: Generics para request/response tipados
- **URL Completa**: Combina baseURL con procedure
- **Schema**: Metadata para validación
- **Opciones**: Configuración personalizable

## Estructura chatServiceClient

```go
type chatServiceClient struct {
    sendMessage           *connect.Client[v1.SendMessageRequest, v1.SendMessageResponse]
    editMessage           *connect.Client[v1.EditMessageRequest, v1.EditMessageResponse]
    deleteMessage         *connect.Client[v1.DeleteMessageRequest, v1.DeleteMessageResponse]
    // ... (continúa con todos los métodos)
}
```

**Análisis:**
- **Composición**: Un cliente Connect por cada método RPC
- **Type Safety**: Cada cliente está tipado específicamente
- **Reutilización**: Clientes reutilizables para múltiples calls

### Implementación de Métodos

```go
func (c *chatServiceClient) SendMessage(ctx context.Context, req *connect.Request[v1.SendMessageRequest]) (*connect.Response[v1.SendMessageResponse], error) {
    return c.sendMessage.CallUnary(ctx, req)
}
```

**Patrón:**
- **Delegación**: Delega al cliente específico
- **CallUnary**: Para métodos request-response
- **CallServerStream**: Para métodos de streaming

## Interface ChatServiceHandler

```go
type ChatServiceHandler interface {
    // Enviar mensaje
    // 🔒 Need private token to access this endpoint
    SendMessage(context.Context, *connect.Request[v1.SendMessageRequest]) (*connect.Response[v1.SendMessageResponse], error)
    
    // ... (métodos similares al cliente)
    
    // Stream unidireccional para mensajes en tiempo real
    // 🔒 Need private token to access this endpoint
    StreamMessages(context.Context, *connect.Request[v1.StreamMessagesRequest], *connect.ServerStream[v1.MessageEvent]) error
}
```

**Diferencias con ChatServiceClient:**

### Métodos de Streaming
```go
// Cliente
StreamMessages(context.Context, *connect.Request[v1.StreamMessagesRequest]) (*connect.ServerStreamForClient[v1.MessageEvent], error)

// Handler
StreamMessages(context.Context, *connect.Request[v1.StreamMessagesRequest], *connect.ServerStream[v1.MessageEvent]) error
```

**Análisis:**
- **Cliente**: Retorna stream para recibir eventos
- **Handler**: Recibe stream para enviar eventos
- **Perspectiva**: Diferentes perspectivas de la misma operación

## Función NewChatServiceHandler

```go
func NewChatServiceHandler(svc ChatServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
    chatServiceMethods := v1.File_services_chat_v1_service_proto.Services().ByName("ChatService").Methods()
    
    // Crear handlers individuales para cada método
    chatServiceSendMessageHandler := connect.NewUnaryHandler(
        ChatServiceSendMessageProcedure,
        svc.SendMessage,
        connect.WithSchema(chatServiceMethods.ByName("SendMessage")),
        connect.WithHandlerOptions(opts...),
    )
    
    // ... (continúa con todos los métodos)
    
    return "/services.chat.v1.ChatService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        switch r.URL.Path {
        case ChatServiceSendMessageProcedure:
            chatServiceSendMessageHandler.ServeHTTP(w, r)
        case ChatServiceEditMessageProcedure:
            chatServiceEditMessageHandler.ServeHTTP(w, r)
        // ... (continúa con todos los casos)
        default:
            http.NotFound(w, r)
        }
    })
}
```

**Análisis del Proceso:**

### 1. Creación de Handlers
- **Unary**: `connect.NewUnaryHandler` para métodos request-response
- **Streaming**: `connect.NewServerStreamHandler` para streaming
- **Configuración**: Schema y opciones por método

### 2. Router HTTP
- **Path Matching**: Switch basado en URL path
- **Delegación**: Cada path delega a su handler específico
- **404**: Paths no reconocidos retornan Not Found

### 3. Retorno
- **Mount Path**: `"/services.chat.v1.ChatService/"` para registro
- **Handler**: `http.Handler` compatible con servidores estándar

## Estructura UnimplementedChatServiceHandler

```go
type UnimplementedChatServiceHandler struct{}

func (UnimplementedChatServiceHandler) SendMessage(context.Context, *connect.Request[v1.SendMessageRequest]) (*connect.Response[v1.SendMessageResponse], error) {
    return nil, connect.NewError(connect.CodeUnimplemented, errors.New("services.chat.v1.ChatService.SendMessage is not implemented"))
}
```

**Propósito:**
- **Base Implementation**: Implementación base que retorna "no implementado"
- **Desarrollo Incremental**: Permite implementar métodos gradualmente
- **Testing**: Útil para testing de métodos específicos
- **Error Estándar**: Retorna error gRPC estándar `UNIMPLEMENTED`

## Protocolos Soportados

### 1. gRPC Nativo
- **Transport**: HTTP/2
- **Encoding**: Protocol Buffers binario
- **Uso**: Comunicación servidor-servidor

### 2. gRPC-Web
- **Transport**: HTTP/1.1 o HTTP/2
- **Encoding**: Protocol Buffers binario
- **Uso**: Navegadores web con proxy

### 3. Connect Protocol
- **Transport**: HTTP/1.1 o HTTP/2
- **Encoding**: JSON o Protocol Buffers
- **Uso**: APIs REST-like con type safety

## Configuración de Cliente

### Opciones Comunes

```go
client := chatv1connect.NewChatServiceClient(
    http.DefaultClient,
    "https://api.example.com",
    connect.WithGRPC(),                    // Usar protocolo gRPC
    connect.WithCompression("gzip"),       // Compresión
    connect.WithClientOptions(
        connect.WithInterceptors(authInterceptor), // Middleware
    ),
)
```

### Interceptors

```go
func authInterceptor() connect.UnaryInterceptorFunc {
    return func(next connect.UnaryFunc) connect.UnaryFunc {
        return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {
            req.Header().Set("Authorization", "Bearer "+token)
            return next(ctx, req)
        }
    }
}
```

## Mejores Prácticas

### 1. **Reutilización de Clientes**
```go
// Crear una vez, usar múltiples veces
var chatClient = chatv1connect.NewChatServiceClient(...)

func sendMessage(msg string) error {
    return chatClient.SendMessage(ctx, request)
}
```

### 2. **Manejo de Errores**
```go
response, err := client.SendMessage(ctx, request)
if err != nil {
    if connectErr := new(connect.Error); errors.As(err, &connectErr) {
        switch connectErr.Code() {
        case connect.CodeUnauthenticated:
            // Renovar token
        case connect.CodePermissionDenied:
            // Mostrar error de permisos
        }
    }
}
```

### 3. **Context con Timeout**
```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

response, err := client.SendMessage(ctx, request)
```

### 4. **Streaming con Cleanup**
```go
stream, err := client.StreamMessages(ctx, request)
if err != nil {
    return err
}
defer stream.Close()

for stream.Receive() {
    event := stream.Msg()
    // Procesar evento
}
```

Este archivo generado proporciona una interfaz completa y type-safe para interactuar con el servicio de chat, soportando múltiples protocolos y patrones de comunicación modernos.