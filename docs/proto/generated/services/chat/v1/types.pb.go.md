# Documentación Técnica: proto/generated/services/chat/v1/types.pb.go

## Descripción General

Este archivo es **código generado automáticamente** por `protoc-gen-go` a partir del archivo `services/chat/v1/types.proto`. Contiene todas las estructuras de datos, enums, requests y responses utilizados por el servicio de chat. Es el núcleo de los tipos de datos que definen la funcionalidad completa del sistema de mensajería, incluyendo salas, mensajes, eventos en tiempo real y sincronización.

## Estructura del Archivo

### Información de Generación

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//  protoc-gen-go v1.36.8
//  protoc        (unknown)
// source: services/chat/v1/types.proto
```

**Análisis:**
- **Herramienta**: `protoc-gen-go` versión 1.36.8
- **Fuente**: `services/chat/v1/types.proto`
- **Prohibición de edición**: Código generado automáticamente

## Enumeraciones (Enums)

### MessageStatus

```go
type MessageStatus int32

const (
    MessageStatus_MESSAGE_STATUS_UNSPECIFIED MessageStatus = 0
    MessageStatus_MESSAGE_STATUS_SENDING     MessageStatus = 1
    MessageStatus_MESSAGE_STATUS_SENT        MessageStatus = 2
    MessageStatus_MESSAGE_STATUS_DELIVERED   MessageStatus = 3
    MessageStatus_MESSAGE_STATUS_READ        MessageStatus = 4
    MessageStatus_MESSAGE_STATUS_ERROR       MessageStatus = 5
)
```

**Análisis de Estados:**

#### `MESSAGE_STATUS_UNSPECIFIED (0)`
- **Uso**: Estado inicial o no definido
- **Contexto**: Valor por defecto en Protocol Buffers
- **Aplicación**: Mensajes sin estado específico

#### `MESSAGE_STATUS_SENDING (1)`
- **Uso**: Mensaje en proceso de envío
- **UI**: Mostrar indicador de "enviando"
- **Duración**: Estado temporal hasta confirmación

#### `MESSAGE_STATUS_SENT (2)`
- **Uso**: Mensaje enviado al servidor
- **Confirmación**: Servidor ha recibido el mensaje
- **UI**: Mostrar marca de "enviado" (✓)

#### `MESSAGE_STATUS_DELIVERED (3)`
- **Uso**: Mensaje entregado al destinatario
- **Confirmación**: Dispositivo del destinatario ha recibido
- **UI**: Mostrar marca de "entregado" (✓✓)

#### `MESSAGE_STATUS_READ (4)`
- **Uso**: Mensaje leído por el destinatario
- **Confirmación**: Usuario ha visto el mensaje
- **UI**: Mostrar marca de "leído" (✓✓ azul)

#### `MESSAGE_STATUS_ERROR (5)`
- **Uso**: Error en el envío del mensaje
- **Manejo**: Permitir reintento o mostrar error
- **UI**: Mostrar indicador de error (⚠️)

### SyncStrategy

```go
type SyncStrategy int32

const (
    SyncStrategy_SYNC_STRATEGY_UNSPECIFIED SyncStrategy = 0
    SyncStrategy_SYNC_STRATEGY_FULL        SyncStrategy = 1 // Historial completo
    SyncStrategy_SYNC_STRATEGY_RECENT      SyncStrategy = 2 // Solo mensajes recientes (30 días)
    SyncStrategy_SYNC_STRATEGY_MINIMAL     SyncStrategy = 3 // Solo último mensaje
    SyncStrategy_SYNC_STRATEGY_SMART       SyncStrategy = 4 // Inteligente según condiciones
)
```

**Análisis de Estrategias:**

#### `SYNC_STRATEGY_FULL (1)`
- **Uso**: Sincronización completa del historial
- **Aplicación**: Primera instalación o reset completo
- **Impacto**: Alto uso de ancho de banda y almacenamiento

#### `SYNC_STRATEGY_RECENT (2)`
- **Uso**: Solo mensajes de los últimos 30 días
- **Aplicación**: Sincronización después de ausencia prolongada
- **Balance**: Equilibrio entre completitud y eficiencia

#### `SYNC_STRATEGY_MINIMAL (3)`
- **Uso**: Solo el último mensaje por sala
- **Aplicación**: Vista rápida de salas activas
- **Eficiencia**: Mínimo uso de recursos

#### `SYNC_STRATEGY_SMART (4)`
- **Uso**: Estrategia adaptativa según condiciones
- **Factores**: Conexión, almacenamiento, uso histórico
- **Optimización**: Mejor experiencia de usuario

## Estructuras de Datos Principales

### Room

```go
type Room struct {
    Id               string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
    Name             string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
    Description      string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
    PhotoUrl         string                 `protobuf:"bytes,4,opt,name=photo_url,json=photoUrl,proto3" json:"photo_url,omitempty"`
    EncryptionData   string                 `protobuf:"bytes,5,opt,name=encryption_data,json=encryptionData,proto3" json:"encryption_data,omitempty"`
    Type             string                 `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
    UnreadCount      int32                  `protobuf:"varint,7,opt,name=unread_count,json=unreadCount,proto3" json:"unread_count,omitempty"`
    Role             string                 `protobuf:"bytes,8,opt,name=role,proto3" json:"role,omitempty"`
    // ... más campos
}
```

**Análisis de Campos:**

#### Identificación y Metadatos
- **`Id`**: Identificador único de la sala (UUID)
- **`Name`**: Nombre de la sala (para grupos) o nombre del contacto (P2P)
- **`Description`**: Descripción opcional de la sala
- **`PhotoUrl`**: URL de la imagen/avatar de la sala

#### Seguridad
- **`EncryptionData`**: Datos de encriptación específicos de la sala
- **`Type`**: Tipo de sala ("p2p" o "group")

#### Estado del Usuario
- **`UnreadCount`**: Número de mensajes no leídos
- **`Role`**: Rol del usuario en la sala ("owner", "admin", "member")
- **`IsMuted`**: Si las notificaciones están silenciadas
- **`IsPinned`**: Si la sala está fijada

#### Permisos
- **`JoinAllUser`**: Si cualquier usuario puede unirse
- **`SendMessage`**: Si se pueden enviar mensajes
- **`AddMember`**: Si se pueden agregar miembros
- **`EditGroup`**: Si se puede editar la configuración

#### Relaciones
- **`Partner`**: Información del contacto en chats P2P
- **`Participants`**: Lista de participantes en grupos
- **`LastMessage`**: Último mensaje de la sala

### MessageData

```go
type MessageData struct {
    Id                           string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
    RoomId                       string                 `protobuf:"bytes,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
    SenderId                     int32                  `protobuf:"varint,3,opt,name=sender_id,json=senderId,proto3" json:"sender_id,omitempty"`
    SenderName                   string                 `protobuf:"bytes,4,opt,name=sender_name,json=senderName,proto3" json:"sender_name,omitempty"`
    Content                      string                 `protobuf:"bytes,7,opt,name=content,proto3" json:"content,omitempty"`
    Status                       MessageStatus          `protobuf:"varint,15,opt,name=status,proto3,enum=services.chat.v1.MessageStatus" json:"status,omitempty"`
    Type                         string                 `protobuf:"bytes,18,opt,name=type,proto3" json:"type,omitempty"`
    // ... más campos
}
```

**Análisis de Campos:**

#### Identificación
- **`Id`**: ID único del mensaje (TimeUUID)
- **`RoomId`**: ID de la sala donde se envió
- **`SenderMessageId`**: ID del cliente para idempotencia

#### Información del Remitente
- **`SenderId`**: ID del usuario que envió
- **`SenderName`**: Nombre del remitente
- **`SenderAvatar`**: Avatar del remitente
- **`SenderPhone`**: Teléfono del remitente

#### Contenido
- **`Content`**: Contenido del mensaje (encriptado)
- **`Type`**: Tipo de mensaje ("user_message", "system", "file", etc.)
- **`File`**: URL de archivo adjunto

#### Estado y Metadatos
- **`Status`**: Estado del mensaje (enviado, entregado, leído)
- **`CreatedAt`**: Timestamp de creación (ISO 8601)
- **`UpdatedAt`**: Timestamp de última actualización
- **`Edited`**: Si el mensaje fue editado
- **`IsDeleted`**: Si el mensaje fue eliminado (soft delete)

#### Funcionalidades Avanzadas
- **`Reply`**: Mensaje al que responde (nested MessageData)
- **`Mentions`**: Lista de menciones (@usuario)
- **`Reactions`**: Lista de reacciones emoji
- **`ForwardedMessage*`**: Información de mensaje reenviado

#### Contenido Multimedia
- **`AudioTranscription`**: Transcripción de audio
- **`LocationName`**: Nombre de ubicación
- **`LocationLatitude/Longitude`**: Coordenadas GPS
- **`ContactName/Phone`**: Información de contacto compartido

### RoomParticipant

```go
type RoomParticipant struct {
    Id               int32                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
    Phone            string                 `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
    Name             string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
    Avatar           string                 `protobuf:"bytes,4,opt,name=avatar,proto3" json:"avatar,omitempty"`
    Role             string                 `protobuf:"bytes,5,opt,name=role,proto3" json:"role,omitempty"`
    IsPartnerBlocked bool                   `protobuf:"varint,6,opt,name=is_partner_blocked,json=isPartnerBlocked,proto3" json:"is_partner_blocked,omitempty"`
    IsPartnerMuted   bool                   `protobuf:"varint,7,opt,name=is_partner_muted,json=isPartnerMuted,proto3" json:"is_partner_muted,omitempty"`
}
```

**Análisis:**
- **Información básica**: ID, teléfono, nombre, avatar
- **Rol**: Posición en la sala (owner, admin, member)
- **Estado de relación**: Bloqueado o silenciado

## Eventos en Tiempo Real

### MessageEvent

```go
type MessageEvent struct {
    Room    *Room                  `protobuf:"bytes,1,opt,name=room,proto3,oneof" json:"room,omitempty"`
    RoomId  string                 `protobuf:"bytes,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
    EventId string                 `protobuf:"bytes,100,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
    Event   isMessageEvent_Event   `protobuf_oneof:"event"`
}
```

**Tipos de Eventos (OneOf):**

#### Eventos de Mensajes
- **`Message`**: Nuevo mensaje recibido
- **`UpdateMessage`**: Mensaje editado
- **`DeleteMessage`**: Mensaje eliminado
- **`StatusUpdate`**: Cambio de estado de mensaje

#### Eventos de Sala
- **`IsRoomUpdated`**: Sala actualizada
- **`RoomJoin`**: Usuario se unió a la sala
- **`RoomLeave`**: Usuario salió de la sala

#### Eventos de Interacción
- **`Typing`**: Usuario escribiendo
- **`Error`**: Error en el stream
- **`Connected`**: Ping de conexión

### TypingEvent

```go
type TypingEvent struct {
    UserId    int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
    IsTyping  bool   `protobuf:"varint,2,opt,name=is_typing,json=isTyping,proto3" json:"is_typing,omitempty"`
    UpdatedAt string `protobuf:"bytes,3,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}
```

**Uso:**
- **`IsTyping: true`**: Usuario empezó a escribir
- **`IsTyping: false`**: Usuario dejó de escribir
- **Timeout**: Auto-expiración después de inactividad

## Requests y Responses

### SendMessageRequest

```go
type SendMessageRequest struct {
    RoomId            string                 `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
    Content           string                 `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
    ReplyId           *string                `protobuf:"bytes,3,opt,name=reply_id,json=replyId,proto3,oneof" json:"reply_id,omitempty"`
    Mentions          []*CreateMention       `protobuf:"bytes,4,rep,name=mentions,proto3" json:"mentions,omitempty"`
    Type              string                 `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
    // ... campos opcionales para multimedia
}
```

**Campos Opcionales:**
- **`Lifetime`**: Tiempo de vida del mensaje
- **`LocationName/Latitude/Longitude`**: Ubicación
- **`ContactName/Phone`**: Contacto compartido
- **`File`**: Archivo adjunto
- **`ForwardId`**: ID del mensaje a reenviar
- **`Event`**: Datos de evento personalizado
- **`SenderMessageId`**: ID del cliente para idempotencia

### GetRoomsRequest

```go
type GetRoomsRequest struct {
    Page   uint32 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
    Limit  uint32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"` // Máximo 50 rooms
    Search string `protobuf:"bytes,3,opt,name=search,proto3" json:"search,omitempty"`
    Type   string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
    Since  string `protobuf:"bytes,5,opt,name=since,proto3" json:"since,omitempty"`
}
```

**Funcionalidades:**
- **Paginación**: Page y Limit para grandes listas
- **Búsqueda**: Filtro por nombre de sala
- **Tipo**: Filtro por tipo de sala (p2p, group)
- **Since**: Sincronización incremental

### InitialSyncRequest

```go
type InitialSyncRequest struct {
    LastSyncTimestamp    string       `protobuf:"bytes,1,opt,name=last_sync_timestamp,json=lastSyncTimestamp,proto3" json:"last_sync_timestamp,omitempty"`
    SyncStrategy         SyncStrategy `protobuf:"varint,2,opt,name=sync_strategy,json=syncStrategy,proto3,enum=services.chat.v1.SyncStrategy" json:"sync_strategy,omitempty"`
    MessagesPerRoom      int32        `protobuf:"varint,3,opt,name=messages_per_room,json=messagesPerRoom,proto3" json:"messages_per_room,omitempty"`
    IncludeArchivedRooms bool         `protobuf:"varint,4,opt,name=include_archived_rooms,json=includeArchivedRooms,proto3" json:"include_archived_rooms,omitempty"`
}
```

**Configuración de Sincronización:**
- **`LastSyncTimestamp`**: Última sincronización (ISO 8601)
- **`SyncStrategy`**: Estrategia de sincronización
- **`MessagesPerRoom`**: Límite de mensajes por sala (máx 100)
- **`IncludeArchivedRooms`**: Incluir salas archivadas

## Funciones Getter Generadas

### Patrón de Getters

Cada estructura tiene getters automáticos que manejan valores nil:

```go
func (x *Room) GetId() string {
    if x != nil {
        return x.Id
    }
    return ""
}

func (x *Room) GetUnreadCount() int32 {
    if x != nil {
        return x.UnreadCount
    }
    return 0
}
```

**Características:**
- **Null Safety**: Verificación automática de nil
- **Valores por defecto**: Retorna valores zero apropiados
- **Consistencia**: Mismo patrón para todos los tipos

### Getters para Campos Opcionales

```go
func (x *MessageData) GetForwardedMessageId() string {
    if x != nil && x.ForwardedMessageId != nil {
        return *x.ForwardedMessageId
    }
    return ""
}
```

**Manejo de Punteros:**
- **Doble verificación**: Struct y puntero no nil
- **Dereferencia segura**: Evita panic por nil pointer
- **Valores por defecto**: Retorna zero value si es nil

## Métodos de Protocol Buffers

### Métodos Estándar

Cada tipo implementa la interfaz `proto.Message`:

```go
func (x *Room) Reset() {
    *x = Room{}
    // ... inicialización de metadata
}

func (x *Room) String() string {
    return protoimpl.X.MessageStringOf(x)
}

func (*Room) ProtoMessage() {}

func (x *Room) ProtoReflect() protoreflect.Message {
    // ... implementación de reflection
}
```

**Funcionalidades:**
- **Reset**: Reinicia la estructura a valores por defecto
- **String**: Representación string para debugging
- **ProtoMessage**: Marca como mensaje de Protocol Buffers
- **ProtoReflect**: Soporte para reflection

## Uso Típico de los Tipos

### Envío de Mensaje

```go
request := &chatv1.SendMessageRequest{
    RoomId:  "room_123",
    Content: "Hola mundo!",
    Type:    "user_message",
    Mentions: []*chatv1.CreateMention{
        {
            Tag:  "@juan",
            User: "user_456",
        },
    },
}

response, err := client.SendMessage(ctx, connect.NewRequest(request))
if err != nil {
    log.Printf("Error: %v", err)
    return
}

message := response.Msg.GetMessage()
log.Printf("Mensaje enviado: %s", message.GetId())
```

### Manejo de Eventos

```go
stream, err := client.StreamMessages(ctx, connect.NewRequest(&chatv1.StreamMessagesRequest{}))
if err != nil {
    log.Printf("Error: %v", err)
    return
}

for stream.Receive() {
    event := stream.Msg()
    
    switch e := event.GetEvent().(type) {
    case *chatv1.MessageEvent_Message:
        handleNewMessage(e.Message)
    case *chatv1.MessageEvent_Typing:
        handleTyping(e.Typing)
    case *chatv1.MessageEvent_StatusUpdate:
        handleStatusUpdate(e.StatusUpdate)
    }
}
```

### Sincronización Inicial

```go
request := &chatv1.InitialSyncRequest{
    SyncStrategy:    chatv1.SyncStrategy_SYNC_STRATEGY_RECENT,
    MessagesPerRoom: 50,
}

response, err := client.InitialSync(ctx, connect.NewRequest(request))
if err != nil {
    log.Printf("Error: %v", err)
    return
}

for _, room := range response.Msg.GetRooms() {
    log.Printf("Sala: %s, Mensajes no leídos: %d", 
        room.GetName(), room.GetUnreadCount())
}
```

## Consideraciones de Performance

### Campos Opcionales

Los campos opcionales usan punteros para distinguir entre "no establecido" y "valor zero":

```go
// Campo opcional
LocationLatitude *float64

// Uso
if msg.LocationLatitude != nil {
    lat := *msg.LocationLatitude
    // usar latitud
}
```

### Reutilización de Estructuras

```go
// Reutilizar estructuras para evitar allocations
var request chatv1.SendMessageRequest
request.Reset()
request.RoomId = "room_123"
request.Content = "mensaje"
```

### Serialización Eficiente

```go
// Protocol Buffers binario (más eficiente)
data, err := proto.Marshal(message)

// JSON (más legible, menos eficiente)
jsonData, err := protojson.Marshal(message)
```

## Mejores Prácticas

1. **Usar getters**: Siempre usar métodos Get* para acceso seguro
2. **Verificar nil**: Verificar punteros antes de dereferencia
3. **Reutilizar estructuras**: Reset() para reutilización
4. **Manejo de errores**: Verificar errores en serialización
5. **Campos opcionales**: Usar punteros apropiadamente
6. **Validation**: Validar datos antes de envío

Este archivo define el modelo de datos completo del sistema de chat, proporcionando type safety y eficiencia en la comunicación entre cliente y servidor.